# PulumiToTerraformName performs a standard transformation on the given name string, from Pulumi's PascalCasing or
# camelCasing, to Terraform's underscore_casing.
from copy import copy
import enum
import json
import random
import re
from dataclasses import dataclass
from typing import Any, Callable, Dict, List, Optional, TypedDict, Union

import inflect

RE_UPPER_CASE = re.compile(r"([A-Z])")
RE_UNDERSCORE = re.compile(r"_([a-z])")
ENGINE = inflect.engine()

Transformer = Callable[[Any], Any]


@dataclass
class DefaultInfo:
    # AutoNamed is true if this default represents an autogenerated name.
    AutoNamed: Optional[bool] = None
    # Config uses a configuration variable from this package as the default value.
    Config: Optional[str] = None
    # From applies a transformation from other resource properties.
    From: Optional[Callable] = None
    # Value injects a raw literal value as the default.
    Value: Optional[Any] = None
    # EnvVars to use for defaults. If none of these variables have values at runtime, the value of `Value` (if any)
    # will be used as the default.
    EnvVars: Optional[List[str]] = None


class ArchiveFormat(enum.Enum):
    NotArchive = 0  # not an archive
    TarArchive = 1  # a POSIX tar archive.
    TarGZIPArchive = 2  # a POSIX tar gzip archive
    ZIPArchive = 3  # a multi-file ZIP archive.
    JARArchive = 4  # a Java JAR file


class AssetTranslationKind(enum.Enum):
    # FileAsset turns the asset into a file on disk and passes the filename in its place.
    FileAsset = 0
    # BytesAsset turns the asset into a []byte and passes it directly in-memory.
    BytesAsset = enum.auto()
    # FileArchive turns the archive into a file on disk and passes the filename in its place.
    FileArchive = enum.auto()
    # BytesArchive turns the asset into a []byte and passes that directly in-memory.
    BytesArchive = enum.auto()


@dataclass
class AssetTranslation:
    Kind: AssetTranslationKind  # the kind of translation to perform.
    Format: ArchiveFormat = (
        ArchiveFormat.NotArchive
    )  # an archive format, required if this is an archive.
    HashField: Optional[str] = None  # a field to store the hash into, if any.


# SchemaInfo contains optional name transformations to apply.
@dataclass
class SchemaInfo:
    # a name to override the default; "" uses the default.
    Name: Optional[str] = None
    # a name to override the default when targeting C#; "" uses the default.
    CSharpName: Optional[str] = None
    # a type to override the default; "" uses the default.
    Type: Optional[str] = None
    # alternative types that can be used instead of the override.
    AltTypes: Optional[List[str]] = None
    # a type to override when the property is a nested structure.
    NestedType: Optional[str] = None
    # an optional idemponent transformation, applied before passing to TF.
    Transform: "Optional[Transformer]" = None
    # a schema override for elements for arrays, maps, and sets.
    Elem: "Optional[SchemaInfo]" = None
    # a map of custom field names; if a type is missing, the default is used.
    Fields: "Optional[Dict[str, Any]]" = None
    # a map of asset translation information, if this is an asset.
    # Asset: AssetTranslation

    # an optional default directive to be applied if a value is missing.
    Default: "Optional[DefaultInfo]" = None
    # to override whether a property is stable or not.
    Stable: Optional[bool] = None
    # to override whether this property should project as a scalar or array.
    MaxItemsOne: Optional[bool] = None
    # to remove empty object array elements
    SuppressEmptyMapElements: Optional[bool] = None
    # this will make the parameter as computed and not allow the user to set it
    MarkAsComputedOnly: Optional[bool] = None
    # this will make the parameter optional in the schema
    MarkAsOptional: Optional[bool] = None
    # the deprecation message for the property
    DeprecationMessage: Optional[str] = None
    # whether a change in the configuration would force a new resource
    ForceNew: Optional[bool] = None
    # whether or not this property has been removed from the Terraform schema
    Removed: Optional[bool] = None
    # whether or not to treat this property as secret
    Secret: Optional[bool] = None

    access_logs: "Optional[Dict[str, Any]]" = None
    health_check: "Optional[Dict[str, Any]]" = None
    stickiness: "Optional[Dict[str, Any]]" = None
    load_balancer_type: "Optional[Dict[str, Any]]" = None
    ip_address_type: "Optional[Dict[str, Any]]" = None


def pulumi_to_terraform_name(
    name: str,
    terraform_schema: Optional[dict] = None,
    pulumi_schema: Optional[dict[str, Any]] = None,
):
    result = RE_UPPER_CASE.sub(r"_\1", name).lower()
    # Singularize names which were pluralized because they were array-shaped Pulumi values
    if terraform_schema is not None:
        singularResult = ENGINE.singular_noun(result)
        if isinstance(singularResult, bool):
            raise Exception("invalid result")
        # Note: If the name is not found in it's singular form in the schema map, that may
        # be because the TF name was already plural, and thus pluralization was a noop.
        # In this case, we know we should return the raw (plural) result.
        info: "SchemaInfo| None" = None
        sch = terraform_schema.get(singularResult)
        if pulumi_schema is not None and (p := pulumi_schema.get("singularResult")):
            info = p
        if check_tf_max_items(sch, False) or is_pulumi_max_items_one(info):
            result = singularResult

    return result


def terraform_to_pulumi_name(
    name: str,
    terraform_schema: Optional[dict] = None,
    pulumi_schema: Optional[SchemaInfo] = None,
    pascal_case: bool = False,
) -> str:
    """TerraformToPulumiName performs a standard transformation on the given name string, from Terraform's underscore_casing
    to Pulumi's PascalCasing (if upper is true) or camelCasing (if upper is false)."""
    result: str = name

    # Pluralize names that will become array-shaped Pulumi values
    if not is_pulumi_max_items_one(pulumi_schema) and check_tf_max_items(
        terraform_schema, False
    ):
        pluralized = ENGINE.plural_noun(name)
        if pluralized == name or ENGINE.singular_noun(pluralized) == name:
            result = pluralized
        result = ENGINE.plural_noun(name)

    initial = ""
    if result.startswith("_"):
        initial = "_"
        result = result[1:]
    words = result.split("_")
    result = f"{initial}{words[0].title() if pascal_case else words[0]}" + "".join(
        word.title() for word in words[1:]
    )

    return result


def check_tf_max_items(tfs, maxItemsOne: bool) -> bool:
    if tfs is None:
        return False

    if not callable(getattr(tfs, "MaxItems", None)):
        return False

    return (tfs.MaxItems() == 1) == maxItemsOne


def is_pulumi_max_items_one(ps: Optional[SchemaInfo]) -> bool:
    return ps is not None and ps.MaxItemsOne is not None


# TerraformToPulumiName performs a standard transformation on the given name string,
# from Terraform's underscore_casing to Pulumi's PascalCasing (if upper is true) or
# camelCasing (if upper is false).
# def TerraformToPulumiName(
#     name: str, sch: "shim.Schema", ps: List[SchemaInfo], upper: bool
# ) -> str:
#     result: str

#     # Pluralize names that will become array-shaped Pulumi values
#     if not is_pulumi_max_items_one(ps) and check_tf_max_items(sch, False):
#         pluralized = ENGINE.plural_noun(name)
#         if pluralized == name or ENGINE.singular_noun(pluralized) == "name":
#             #            contract.Assertf(
#             #                inflector.Pluralize(name) == name || inflector.Singularize(inflector.Pluralize(name)) == name,
#             #                "expected to be able to safely pluralize "name": %s (%s, %s)", name, inflector.Pluralize(name),
#             #                inflector.Singularize(inflector.Pluralize(name)))

#             name = pluralized
#         name = ENGINE.plural_noun(name)

#     result = RE_UNDERSCORE.sub(r"\1", name, -1)
#     return result


class MODS(enum.Enum):
    # packages:
    awsPkg = ("aws",)
    # modules:
    awsMod = "index"  # the root index.
    acmMod = "Acm"  # AWS Certificate Manager
    acmpcaMod = "Acmpca"  # AWS Private Certificate Authority
    accessAnalyzerMod = "AccessAnalyzer"  # Access Analyzer
    ampMod = "Amp"  # Amp
    amplifyMod = "Amplify"  # Amplify
    appConfigMod = "AppConfig"  # AppConfig
    appStreamMod = "AppStream"  # AppStream
    appsyncMod = "AppSync"  # AppSync
    appmeshMod = "AppMesh"  # AppMesh
    apigatewayMod = "ApiGateway"  # API Gateway
    apigatewayv2Mod = "ApiGatewayV2"  # API Gateway V2
    appautoscalingMod = "AppAutoScaling"  # Application Auto Scaling
    appRunnerMod = "AppRunner"  # AppRunner
    athenaMod = "Athena"  # Athena
    autoscalingMod = "AutoScaling"  # Auto Scaling
    autoscalingPlansMod = "AutoScalingPlans"  # Auto Scaling Plans
    backupMod = "Backup"  # Backup
    batchMod = "Batch"  # Batch
    budgetsMod = "Budgets"  # Budgets
    chimeMod = "Chime"  # Chime
    cloud9Mod = "Cloud9"  # Cloud9
    cloudformationMod = "CloudFormation"  # Cloud Formation
    cloudhsmv2Mod = "CloudHsmV2"  # Cloud HSM
    cloudfrontMod = "CloudFront"  # Cloud Front
    cloudtrailMod = "CloudTrail"  # Cloud Trail
    cloudwatchMod = "CloudWatch"  # Cloud Watch
    codeartifactMod = "CodeArtifact"  # CodeArtifact
    codebuildMod = "CodeBuild"  # Code Build
    codecommitMod = "CodeCommit"  # Code Commit
    codedeployMod = "CodeDeploy"  # Code Deploy
    codepipelineMod = "CodePipeline"  # Code Pipeline
    codestarConnectionsMod = "CodeStarConnections"  # CodeStar Connections
    codestarNotificationsMod = "CodeStarNotifications"  # CodeStar Notifications
    cognitoMod = "Cognito"  # Cognito
    connectMod = "Connect"  # Connect
    curMod = "Cur"  # Cost and Usage Report
    cfgMod = "Cfg"  # Resource Config
    datapipelineMod = "DataPipeline"  # Data Pipeline
    datasyncMod = "DataSync"  # DataSync
    daxMod = "Dax"  # DynamoDB Accelerator
    dlmMod = "Dlm"  # Data Lifecycle Manager
    devicefarmMod = "DeviceFarm"  # Device Farm
    directoryserviceMod = "DirectoryService"  # Directory Services
    docdbMod = "DocDB"  # Document DB
    dynamodbMod = "DynamoDB"  # DynamoDB
    dxMod = "DirectConnect"  # Direct Connect
    dmsMod = "Dms"  # Data Migraiton Services
    ebsMod = "Ebs"  # Elastic Block Store
    ec2Mod = "Ec2"  # EC2
    ec2ClientVpnMod = "Ec2ClientVpn"  # EC2 Client VPN
    ec2TransitGatewayMod = "Ec2TransitGateway"  # EC2 Transit Gateway
    ecrMod = "Ecr"  # Elastic Container Registry
    ecrPublicMod = "EcrPublic"  # ECR Public
    ecsMod = "Ecs"  # Elastic Container Service
    efsMod = "Efs"  # Elastic Filesystem
    eksMod = "Eks"  # ECS for Kubernetes
    elasticacheMod = "ElastiCache"  # ElastiCache
    elasticbeanstalkMod = "ElasticBeanstalk"  # Elastic Beanstalk
    elasticsearchMod = "ElasticSearch"  # ElasticSearch
    elastictranscoderMod = "ElasticTranscoder"  # Elastic Transcoder
    elbMod = "Elb"  # Elastic Load Balancing
    albMod = "Alb"  # Elastic Load Balancing (V2: Application)
    lbMod = "LB"  # Elastic Load Balancing (V2: Application and Network)
    emrMod = "Emr"  # Elastic MapReduce
    fmsMod = "Fms"  # FMS
    fsxMod = "Fsx"  # FSX
    gameliftMod = "GameLift"  # Gamelift
    glacierMod = "Glacier"  # Glacier
    globalacceleratorMod = "GlobalAccelerator"  # Global Accelerator
    glueMod = "Glue"  # Glue
    guarddutyMod = "GuardDuty"  # Guard Duty
    iamMod = "Iam"  # Identity and Access Management (IAM)
    identityStoreMod = "IdentityStore"  # Identity Store
    imageBuilderMod = "ImageBuilder"  # ImageBuilder
    inspectorMod = "Inspector"  # Inspector
    iotMod = "Iot"  # Internet of Things (IoT)
    kinesisMod = "Kinesis"  # Kinesis
    kinesisAnalyticsMod = "KinesisAnalyticsV2"  # Kinesis Analytics V2
    kmsMod = "Kms"  # Key Management Service (KMS)
    lakeFormationMod = "LakeFormation"  # LakeFormation
    lambdaMod = "Lambda"  # Lambda
    lexMod = "Lex"  # Lex
    licensemanagerMod = "LicenseManager"  # License Manager
    lightsailMod = "LightSail"  # LightSail
    macieMod = "Macie"  # Macie (Classic)
    macie2Mod = "Macie2"  # Macie2
    mediaconvertMod = "MediaConvert"  # Media Convert
    mediapackageMod = "MediaPackage"  # Elemental MediaPackage
    mediastoreMod = "MediaStore"  # Elemental MediaStore
    mqMod = "Mq"  # MQ
    mskMod = "Msk"  # MSK
    mwaaMod = "Mwaa"  # Managed Workflows for Apache Airflow
    neptuneMod = "Neptune"  # Neptune
    networkFirewallMod = "NetworkFirewall"  # Network Firewall
    opsworksMod = "OpsWorks"  # OpsWorks
    organizationsMod = "Organizations"  # Organizations
    outpostsMod = "Outposts"  # Outposts
    pinpointMod = "Pinpoint"  # Pinpoint
    pricingMod = "Pricing"  # Pricing
    qldbMod = "Qldb"  # QLDB
    quicksightMod = "Quicksight"  # Quicksight
    ramMod = "Ram"  # Resource Access Manager
    rdsMod = "Rds"  # Relational Database Service (RDS)
    redshiftMod = "RedShift"  # RedShift
    resourcegroupsMod = "ResourceGroups"  # Resource Groups
    resourcegroupsTaggingApiMod = (
        "ResourceGroupsTaggingApi"  # Resource Groups Tagging Api
    )
    route53Mod = "Route53"  # Route 53 (DNS)
    route53RecoveryControlMod = "Route53RecoveryControl"  # Route 53 Recovery Control
    route53RecoveryReadinessMod = (
        "Route53RecoveryReadiness"  # Route 53 Recovery Readiness
    )
    sagemakerMod = "Sagemaker"  # Sagemaker
    schemasMod = "Schemas"  # Schemas
    securityhubMod = "SecurityHub"  # SecurityHub
    serverlessRepositoryMod = "ServerlessRepository"  # ServerlessRepository
    sesMod = "Ses"  # Simple Email Service (SES)
    signerMod = "Signer"  # Signer
    s3Mod = "S3"  # Simple Storage (S3)
    s3ControlMod = "S3Control"  # S3 Control
    s3OutpostsMod = "S3Outposts"  # S3 Outposts
    ssmMod = "Ssm"  # System Manager
    secretsmanagerMod = "SecretsManager"  # Secrets Manager
    servicecatalogMod = "ServiceCatalog"  # Service Catalog
    servicediscoveryMod = "ServiceDiscovery"  # Service Discovery
    servicequotasMod = "ServiceQuotas"  # Service Quotas
    sfnMod = "Sfn"  # Step Functions (SFN)
    shieldMod = "Shield"  # Shield
    simpledbMod = "SimpleDB"  # Simple DB
    snsMod = "Sns"  # Simple Notification Service (SNS)
    sqsMod = "Sqs"  # Simple Queueing Service (SQS)
    ssoAdminMod = "SsoAdmin"  # SSO Admin
    storagegatewayMod = "StorageGateway"  # Storage Gateway
    swfMod = "Swf"  # Simple Workflow Service (SWF)
    syntheticsMod = "Synthetics"  # Synthetics
    timestreamWriteMod = "TimestreamWrite"  # Timestream Write
    transferMod = "Transfer"  # Transfer Service
    wafMod = "Waf"  # Web Application Firewall (WAF)
    wafV2Mod = "WafV2"  # Web Application Firewall V2 (WAFV2)
    wafregionalMod = "WafRegional"  # Web Application Firewall (WAF) Regional
    worklinkMod = "WorkLink"  # Worklink
    workspacesMod = "Workspaces"  # Workspaces
    xrayMod = "Xray"  # X-Ray

    # Legacy Mods
    legacyElbMod = "ElasticLoadBalancing"
    legacyAlbMod = "ApplicationLoadBalancing"
    legacyElbv2Mod = "ElasticLoadBalancingV2"


NAMESPACE_MAP = {"aws": "Aws"}


def awsResource(module: str, resource: str):
    fn = f"{resource[0].lower()}{resource[1:]}"
    return awsType(module, fn, resource)


def awsDataSource(module: str, resource: str):
    fn = f"{resource[0].lower()}{resource[1:]}"
    return awsType(module, fn, resource)


def awsType(module: str, fn: str, resource: str):
    module_name = module.lower()
    NAMESPACE_MAP[module_name] = module
    if fn != "":
        module_name += f"/{fn}"
    return f"aws:{module_name}:{resource}"


def AutoName(name: str, maxlength: int, separator: str) -> SchemaInfo:
    """AutoName creates custom schema for a Terraform name property which is
    automatically populated from the resource's URN name, and transformed based
    on the ded options."""
    return SchemaInfo(
        Name=name,
        Default=DefaultInfo(
            AutoNamed=True,
            From=FromName(
                Separator=separator,
                Maxlen=maxlength,
                Randlen=7,
            ),
        ),
    )


def AutoNameTransform(
    name: str, maxlen: int, transform: Callable[[str], str]
) -> SchemaInfo:
    return SchemaInfo(
        Name=name,
        Default=DefaultInfo(
            AutoNamed=True,
            From=FromName(
                Separator="-",
                Maxlen=maxlen,
                Randlen=7,
                Transform=transform,
            ),
        ),
    )


def AutoNameWithCustomOptions(name: str, **kwargs) -> SchemaInfo:
    """AutoNameWithCustomOptions creates a custom schema for a Terraform name
    property and allows setting options to allow transforms, custom separators
    and maxLength combinations."""
    return SchemaInfo(
        Name=name,
        Default=DefaultInfo(
            AutoNamed=True,
            From=FromName(**kwargs),
        ),
    )


@dataclass
class PulumiResource:
    URN: str
    Properties: dict


def FromName(
    Separator: str = "",
    Maxlen: int = 0,
    Randlen: int = 0,
    Transform: Callable[[str], str] = None,
    PostTransform: Callable[[PulumiResource, str], str] = None,
):
    def _from_name(res: PulumiResource):
        vs = res.URN
        if Transform is not None:
            vs = Transform(vs)
        if Randlen > 0:
            raise Exception("Randlen not implemented yet, see upstream")
        if PostTransform is not None:
            return PostTransform(res, vs)
        return vs

    return _from_name


def TransformJSONDocument(v: Union[str, dict]) -> str:
    """TransformJSONDocument permits either a string, which is presumed to
    represent an already-stringified JSON document, or a map/array, which will
    be transformed into its JSON representation.
    """
    # We can't marshal properties that contain unknowns. Turn these into an unknown value instead.
    # if v.ContainsUnknowns() {
    #     return resource.MakeComputed(resource.NewStringProperty("")), None
    # }
    if isinstance(v, str):
        return v
    else:
        return json.dumps(v)


def transformWithRandomString(n: int) -> str:
    letters = "abcdefghijklmnopqrstuvwxyz"
    return "".join(random.choices(letters, k=8))


managedByPulumi = {"Value": "Managed by Pulumi"}


class ResourceInfo(TypedDict, total=False):
    Tok: str
    Fields: Dict[str, Any]
    Docs: Dict[str, Any]
    IDFields: List[str]
    Aliases: Any
    DeprecationMessage: str


class DataSourceInfo(TypedDict, total=False):
    Tok: str
    Fields: Dict[str, Any]
    Docs: Dict[str, Any]
    DeprecationMessage: str


class ProviderInfo:
    name: str
    Resources: Dict[str, ResourceInfo] = {}
    ResourcesMap = {}
    DataSources: Dict[str, DataSourceInfo] = {}
    DataSourcesMap = {}

    def RenameResourceWithAlias(
        self,
        resourceName: str,
        legacyTok: str,
        newTok: str,
        legacyModule: str,
        newModule: str,
        info: ResourceInfo = None,
    ):

        resourcePrefix = self.name + "_"
        legacyResourceName = resourceName + "_legacy"
        if info is None:
            info = ResourceInfo()
        legacyInfo = copy(info)
        currentInfo = copy(info)

        legacyInfo["Tok"] = legacyTok
        legacyType = legacyInfo["Tok"]  # type: ignore

        if newTok != "":
            legacyTok = newTok

        currentInfo["Tok"] = legacyTok
        currentInfo["Aliases"] = [
            {"Type": legacyType},
        ]

        if legacyInfo.get("Docs") is None:
            legacyInfo["Docs"] = {
                "Source": resourceName[len(resourcePrefix) :] + ".html.markdown",
            }

        legacyInfo[
            "DeprecationMessage"
        ] = "%s has been deprecated in favor of %s".format(
            generateResourceName(legacyInfo["Tok"], legacyModule.lower(), legacyInfo["Tok"]),  # type: ignore
            generateResourceName(
                currentInfo["Tok"], newModule.lower(), currentInfo["Tok"]  # type: ignore
            ),
        )
        self.Resources[resourceName] = currentInfo
        self.Resources[legacyResourceName] = legacyInfo
        self.ResourcesMap["legacyResourceName"] = self.ResourcesMap.get(resourceName)

    def RenameDataSource(
        self,
        resourceName: str,
        legacyTok: str,
        newTok: str,
        legacyModule: str,
        newModule: str,
        info: DataSourceInfo = None,
    ):

        resourcePrefix = self.name + "_"
        legacyResourceName = resourceName + "_legacy"
        if info is None:
            info = ResourceInfo()
        legacyInfo = copy(info)
        currentInfo = copy(info)

        legacyInfo["Tok"] = legacyTok
        legacyType = legacyInfo["Tok"]  # type: ignore

        if newTok != "":
            legacyTok = newTok

        currentInfo["Tok"] = legacyTok

        if legacyInfo.get("Docs") is None:
            legacyInfo["Docs"] = {
                "Source": resourceName[len(resourcePrefix) :] + ".html.markdown",
            }

        legacyInfo[
            "DeprecationMessage"
        ] = "%s has been deprecated in favor of %s".format(
            generateResourceName(legacyInfo["Tok"], legacyModule.lower(), legacyInfo["Tok"]),  # type: ignore
            generateResourceName(
                currentInfo["Tok"], newModule.lower(), currentInfo["Tok"]  # type: ignore
            ),
        )
        self.DataSources[resourceName] = currentInfo
        self.DataSources[legacyResourceName] = legacyInfo
        self.DataSourcesMap["legacyResourceName"] = self.DataSourcesMap.get(
            resourceName
        )

    def SetAutonaming(self, maxLength: int, separator: str):
        nameProperty = "name"
        for resname, res in self.Resources.items():
            if schema := self.ResourcesMap.get(resname):
                # Only apply auto-name to input properties (Optional || Required) named `name`
                if schema is None:
                    continue
                if sch := schema.get(nameProperty):
                    if sch is None:
                        continue
                    if res.get("Fields") is None:
                        res["Fields"] = {}
                        res["Fields"][nameProperty] = AutoName(nameProperty, maxLength, separator)  # type: ignore


def generateResourceName(
    packageName: str, moduleName: str, moduleMemberName: str
) -> str:
    # We don't want DeprecationMessages that read
    # `postgresql.index.DefaultPrivileg` has been deprecated in favour of `postgresql.index.DefaultPrivileges`
    # we would never use `index` in a reference to the Class. So we should remove this where needed
    if moduleName == "" or moduleName == "index":
        return f"{packageName}.{moduleMemberName}"

    return f"{packageName}.{moduleName}.{moduleMemberName}"


class AwsProviderInfo(ProviderInfo):
    name = "aws"

    Resources: Dict[str, ResourceInfo] = {
        # AWS Certificate Manager
        "aws_acm_certificate": {"Tok": awsResource(MODS.acmMod.value, "Certificate")},
        "aws_acm_certificate_validation": {
            "Tok": awsResource(MODS.acmMod.value, "CertificateValidation")
        },
        # AWS Private Certificate Authority
        "aws_acmpca_certificate_authority": {
            "Tok": awsResource(MODS.acmpcaMod.value, "CertificateAuthority")
        },
        "aws_acmpca_certificate": {
            "Tok": awsResource(MODS.acmpcaMod.value, "Certificate"),
            "Fields": {
                "certificate": {
                    "CSharpName": "CertificateDetails",
                },
            },
        },
        "aws_acmpca_certificate_authority_certificate": {
            "Tok": awsResource(MODS.acmpcaMod.value, "CertificateAuthorityCertificate"),
        },
        # AppSync
        "aws_appsync_api_key": {
            "Tok": awsResource(MODS.appsyncMod.value, "ApiKey"),
            "Fields": {
                "description": {
                    "Default": managedByPulumi,
                },
            },
        },
        "aws_appsync_function": {
            "Tok": awsResource(MODS.appsyncMod.value, "Function"),
            # "Fields": {
            #     "name": {
            #         "Default": {
            #             # This is taken from
            #             # https:#docs.aws.amazon.com/appsync/latest/APIReference/API_CreateFunction.html
            #             From: FromName(AutoNameOptions{
            #                 Separator: "_",
            #                 Maxlen:    255,
            #                 Randlen:   7,
            #             }),
            #         },
            #     },
            # },
        },
        "aws_appsync_graphql_api": {
            "Tok": awsResource(MODS.appsyncMod.value, "GraphQLApi")
        },
        "aws_appsync_datasource": {
            "Tok": awsResource(MODS.appsyncMod.value, "DataSource"),
            "Fields": {
                "name": {
                    "Default": {
                        # This is taken from
                        # https:#docs.aws.amazon.com/appsync/latest/APIReference/API_CreateDataSource.html
                        "From": FromName(Separator="_", Maxlen=255, Randlen=7),
                    },
                },
            },
        },
        "aws_appsync_resolver": {"Tok": awsResource(MODS.appsyncMod.value, "Resolver")},
        # AppMesh
        "aws_appmesh_mesh": {"Tok": awsResource(MODS.appmeshMod.value, "Mesh")},
        "aws_appmesh_route": {"Tok": awsResource(MODS.appmeshMod.value, "Route")},
        "aws_appmesh_virtual_node": {
            "Tok": awsResource(MODS.appmeshMod.value, "VirtualNode")
        },
        "aws_appmesh_virtual_router": {
            "Tok": awsResource(MODS.appmeshMod.value, "VirtualRouter")
        },
        "aws_appmesh_virtual_service": {
            "Tok": awsResource(MODS.appmeshMod.value, "VirtualService")
        },
        "aws_appmesh_gateway_route": {
            "Tok": awsResource(MODS.appmeshMod.value, "GatewayRoute")
        },
        "aws_appmesh_virtual_gateway": {
            "Tok": awsResource(MODS.appmeshMod.value, "VirtualGateway")
        },
        # API Gateway
        "aws_api_gateway_account": {
            "Tok": awsResource(MODS.apigatewayMod.value, "Account"),
            "Fields": {
                "throttle_settings": {
                    "MaxItemsOne": True,
                },
            },
        },
        "aws_api_gateway_api_key": {
            "Tok": awsResource(MODS.apigatewayMod.value, "ApiKey"),
            "Fields": {
                "description": {
                    "Default": managedByPulumi,
                },
            },
        },
        "aws_api_gateway_authorizer": {
            "Tok": awsResource(MODS.apigatewayMod.value, "Authorizer"),
            "Fields": {
                "rest_api_id": {
                    "Name": "restApi",
                    "Type": "string",
                    "AltTypes": [{awsResource(MODS.apigatewayMod.value, "RestApi")}],
                },
            },
        },
        "aws_api_gateway_base_path_mapping": {
            "Tok": awsResource(MODS.apigatewayMod.value, "BasePathMapping"),
            "Fields": {
                "api_id": {
                    "Name": "restApi",
                    "Type": "string",
                    "AltTypes": [{awsResource(MODS.apigatewayMod.value, "RestApi")}],
                },
            },
        },
        "aws_api_gateway_client_certificate": {
            "Tok": awsResource(MODS.apigatewayMod.value, "ClientCertificate")
        },
        "aws_api_gateway_deployment": {
            "Tok": awsResource(MODS.apigatewayMod.value, "Deployment"),
            "Fields": {
                "rest_api_id": {
                    "Name": "restApi",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.apigatewayMod.value, "RestApi")],
                },
            },
        },
        "aws_api_gateway_documentation_part": {
            "Tok": awsResource(MODS.apigatewayMod.value, "DocumentationPart")
        },
        "aws_api_gateway_documentation_version": {
            "Tok": awsResource(MODS.apigatewayMod.value, "DocumentationVersion")
        },
        "aws_api_gateway_domain_name": {
            "Tok": awsResource(MODS.apigatewayMod.value, "DomainName"),
            "Fields": {
                "domain_name": {
                    "CSharpName": "Domain",
                },
            },
        },
        "aws_api_gateway_integration": {
            "Tok": awsResource(MODS.apigatewayMod.value, "Integration"),
            "Fields": {
                "rest_api_id": {
                    "Name": "restApi",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.apigatewayMod.value, "RestApi")],
                },
            },
        },
        "aws_api_gateway_integration_response": {
            "Tok": awsResource(MODS.apigatewayMod.value, "IntegrationResponse"),
            "Fields": {
                "rest_api_id": {
                    "Name": "restApi",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.apigatewayMod.value, "RestApi")],
                },
            },
        },
        "aws_api_gateway_method": {
            "Tok": awsResource(MODS.apigatewayMod.value, "Method"),
            "Fields": {
                "rest_api_id": {
                    "Name": "restApi",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.apigatewayMod.value, "RestApi")],
                },
            },
        },
        "aws_api_gateway_method_response": {
            "Tok": awsResource(MODS.apigatewayMod.value, "MethodResponse"),
            "Fields": {
                "rest_api_id": {
                    "Name": "restApi",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.apigatewayMod.value, "RestApi")],
                },
            },
        },
        "aws_api_gateway_method_settings": {
            "Tok": awsResource(MODS.apigatewayMod.value, "MethodSettings"),
            "Fields": {
                "rest_api_id": {
                    "Name": "restApi",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.apigatewayMod.value, "RestApi")],
                },
            },
        },
        "aws_api_gateway_model": {
            "Tok": awsResource(MODS.apigatewayMod.value, "Model"),
            "Fields": {
                "rest_api_id": {
                    "Name": "restApi",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.apigatewayMod.value, "RestApi")],
                },
            },
        },
        "aws_api_gateway_request_validator": {
            "Tok": awsResource(MODS.apigatewayMod.value, "RequestValidator"),
            "Fields": {
                "rest_api_id": {
                    "Name": "restApi",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.apigatewayMod.value, "RestApi")],
                },
            },
        },
        "aws_api_gateway_resource": {
            "Tok": awsResource(MODS.apigatewayMod.value, "Resource"),
            "Fields": {
                # TODO[pulumi/terraform-bridge#5] Strongly type the parent refernence to align with other uses
                # "parent_id": {
                #     "Name": "parent",
                #     "Type": awsResource(MODS.apigatewayMod.value, "Resource"),
                # },
                "rest_api_id": {
                    "Name": "restApi",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.apigatewayMod.value, "RestApi")],
                },
            },
        },
        "aws_api_gateway_gateway_response": {
            "Tok": awsResource(MODS.apigatewayMod.value, "Response")
        },
        "aws_api_gateway_rest_api": {
            "Tok": awsResource(MODS.apigatewayMod.value, "RestApi")
        },
        "aws_api_gateway_stage": {
            "Tok": awsResource(MODS.apigatewayMod.value, "Stage"),
            "Fields": {
                "deployment_id": {
                    "Name": "deployment",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.apigatewayMod.value, "Deployment")],
                },
                "rest_api_id": {
                    "Name": "restApi",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.apigatewayMod.value, "RestApi")],
                },
            },
        },
        "aws_api_gateway_usage_plan": {
            "Tok": awsResource(MODS.apigatewayMod.value, "UsagePlan")
        },
        "aws_api_gateway_usage_plan_key": {
            "Tok": awsResource(MODS.apigatewayMod.value, "UsagePlanKey")
        },
        "aws_api_gateway_rest_api_policy": {
            "Tok": awsResource(MODS.apigatewayMod.value, "RestApiPolicy")
        },
        "aws_api_gateway_vpc_link": {
            "Tok": awsResource(MODS.apigatewayMod.value, "VpcLink"),
            "Fields": {
                "target_arns": {"Name": "targetArn"},
            },
        },
        # API Gateway v2
        "aws_apigatewayv2_api": {"Tok": awsResource(MODS.apigatewayv2Mod.value, "Api")},
        "aws_apigatewayv2_authorizer": {
            "Tok": awsResource(MODS.apigatewayv2Mod.value, "Authorizer")
        },
        "aws_apigatewayv2_integration": {
            "Tok": awsResource(MODS.apigatewayv2Mod.value, "Integration")
        },
        "aws_apigatewayv2_model": {
            "Tok": awsResource(MODS.apigatewayv2Mod.value, "Model")
        },
        "aws_apigatewayv2_deployment": {
            "Tok": awsResource(MODS.apigatewayv2Mod.value, "Deployment")
        },
        "aws_apigatewayv2_domain_name": {
            "Tok": awsResource(MODS.apigatewayv2Mod.value, "DomainName"),
            "Fields": {
                "domain_name": {
                    "CSharpName": "Domain",
                },
            },
        },
        "aws_apigatewayv2_integration_response": {
            "Tok": awsResource(MODS.apigatewayv2Mod.value, "IntegrationResponse")
        },
        "aws_apigatewayv2_route": {
            "Tok": awsResource(MODS.apigatewayv2Mod.value, "Route")
        },
        "aws_apigatewayv2_route_response": {
            "Tok": awsResource(MODS.apigatewayv2Mod.value, "RouteResponse")
        },
        "aws_apigatewayv2_stage": {
            "Tok": awsResource(MODS.apigatewayv2Mod.value, "Stage")
        },
        "aws_apigatewayv2_api_mapping": {
            "Tok": awsResource(MODS.apigatewayv2Mod.value, "ApiMapping")
        },
        "aws_apigatewayv2_vpc_link": {
            "Tok": awsResource(MODS.apigatewayv2Mod.value, "VpcLink")
        },
        # Application Auto Scaling
        "aws_appautoscaling_policy": {
            "Tok": awsResource(MODS.appautoscalingMod.value, "Policy")
        },
        "aws_appautoscaling_scheduled_action": {
            "Tok": awsResource(MODS.appautoscalingMod.value, "ScheduledAction"),
            "Fields": {
                "scalable_target_action": {
                    "Elem": {
                        "Fields": {
                            "max_capacity": {
                                "Type": "integer",
                            },
                            "min_capacity": {
                                "Type": "integer",
                            },
                        },
                    },
                },
            },
        },
        "aws_appautoscaling_target": {
            "Tok": awsResource(MODS.appautoscalingMod.value, "Target")
        },
        # Athena
        "aws_athena_database": {
            "Tok": awsResource(MODS.athenaMod.value, "Database"),
            "Fields": {
                "name": {
                    "Default": {
                        # From: func(res *PulumiResource) (interface{}, error) {
                        #     return resource.NewUniqueHex(string(res.URN.Name())+"_", 7, 255)
                        # },
                    },
                },
            },
        },
        "aws_athena_named_query": {
            "Tok": awsResource(MODS.athenaMod.value, "NamedQuery")
        },
        "aws_athena_workgroup": {"Tok": awsResource(MODS.athenaMod.value, "Workgroup")},
        # Auto Scaling
        "aws_autoscaling_attachment": {
            "Tok": awsResource(MODS.autoscalingMod.value, "Attachment")
        },
        "aws_autoscaling_group": {
            "Tok": awsResource(MODS.autoscalingMod.value, "Group"),
            "Fields": {
                "launch_configuration": {
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.ec2Mod.value, "LaunchConfiguration")],
                },
                "placement_group": {
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.ec2Mod.value, "PlacementGroup")],
                },
                "enabled_metrics": {
                    "Elem": {
                        "Type": awsType(MODS.autoscalingMod.value, "metrics", "Metric")
                    },
                },
                "metrics_granularity": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(
                            MODS.autoscalingMod.value,
                            "MetricsGranularity",
                            "MetricsGranularity",
                        )
                    ],
                },
                "tag": {
                    # Explicitly map tag => tags to avoid confusion with tags => tagsCollection below.
                    "Name": "tags",
                },
                "tags": {
                    # Conflicts with the pluralized `tag` property, which is the more strongly typed option for
                    # ding tags.  We keep this dynamically typed collection of tags as an option as well, but
                    # give it a different name.
                    "Name": "tagsCollection",
                },
            },
        },
        "aws_autoscaling_lifecycle_hook": {
            "Tok": awsResource(MODS.autoscalingMod.value, "LifecycleHook"),
            "Docs": {
                "Source": "autoscaling_lifecycle_hooks.html.markdown",
            },
        },
        "aws_autoscaling_notification": {
            "Tok": awsResource(MODS.autoscalingMod.value, "Notification"),
            "Fields": {
                "notifications": {
                    "Elem": {
                        "Type": awsResource(
                            MODS.autoscalingMod.value, "NotificationType"
                        )
                    },
                },
            },
        },
        "aws_autoscaling_policy": {
            "Tok": awsResource(MODS.autoscalingMod.value, "Policy")
        },
        "aws_autoscaling_schedule": {
            "Tok": awsResource(MODS.autoscalingMod.value, "Schedule")
        },
        "aws_autoscaling_group_tag": {
            "Tok": awsResource(MODS.autoscalingMod.value, "Tag"),
            "Fields": {
                "tag": {
                    "CSharpName": "TagDetails",
                },
            },
        },
        # Autoscaling Plans
        "aws_autoscalingplans_scaling_plan": {
            "Tok": awsResource(MODS.autoscalingPlansMod.value, "ScalingPlan")
        },
        # Backup
        "aws_backup_plan": {"Tok": awsResource(MODS.backupMod.value, "Plan")},
        "aws_backup_selection": {"Tok": awsResource(MODS.backupMod.value, "Selection")},
        "aws_backup_vault": {"Tok": awsResource(MODS.backupMod.value, "Vault")},
        "aws_backup_vault_notifications": {
            "Tok": awsResource(MODS.backupMod.value, "VaultNotifications")
        },
        "aws_backup_vault_policy": {
            "Tok": awsResource(MODS.backupMod.value, "VaultPolicy")
        },
        "aws_backup_region_settings": {
            "Tok": awsResource(MODS.backupMod.value, "RegionSettings")
        },
        "aws_backup_global_settings": {
            "Tok": awsResource(MODS.backupMod.value, "GlobalSettings"),
            "Fields": {
                "global_settings": {
                    "CSharpName": "GlobalSettingsList",
                },
            },
        },
        # Batch
        "aws_batch_compute_environment": {
            "Tok": awsResource(MODS.batchMod.value, "ComputeEnvironment")
        },
        "aws_batch_job_definition": {
            "Tok": awsResource(MODS.batchMod.value, "JobDefinition")
        },
        "aws_batch_job_queue": {"Tok": awsResource(MODS.batchMod.value, "JobQueue")},
        # Budgets
        "aws_budgets_budget": {"Tok": awsResource(MODS.budgetsMod.value, "Budget")},
        "aws_budgets_budget_action": {
            "Tok": awsResource(MODS.budgetsMod.value, "BudgetAction")
        },
        # Chime
        "aws_chime_voice_connector": {
            "Tok": awsResource(MODS.chimeMod.value, "VoiceConnector")
        },
        "aws_chime_voice_connector_group": {
            "Tok": awsResource(MODS.chimeMod.value, "VoiceConnectorGroup")
        },
        "aws_chime_voice_connector_origination": {
            "Tok": awsResource(MODS.chimeMod.value, "VoiceConnectorOrganization")
        },
        "aws_chime_voice_connector_termination": {
            "Tok": awsResource(MODS.chimeMod.value, "VoiceConnectorTermination")
        },
        "aws_chime_voice_connector_logging": {
            "Tok": awsResource(MODS.chimeMod.value, "VoiceConnectorLogging")
        },
        "aws_chime_voice_connector_streaming": {
            "Tok": awsResource(MODS.chimeMod.value, "VoiceConnectorStreaming")
        },
        # Cloud9
        "aws_cloud9_environment_ec2": {
            "Tok": awsResource(MODS.cloud9Mod.value, "EnvironmentEC2")
        },
        # CloudFormation
        "aws_cloudformation_stack": {
            "Tok": awsResource(MODS.cloudformationMod.value, "Stack")
        },
        "aws_cloudformation_stack_set": {
            "Tok": awsResource(MODS.cloudformationMod.value, "StackSet")
        },
        "aws_cloudformation_stack_set_instance": {
            "Tok": awsResource(MODS.cloudformationMod.value, "StackSetInstance")
        },
        "aws_cloudformation_type": {
            "Tok": awsResource(MODS.cloudformationMod.value, "CloudFormationType")
        },
        # CloudHSM
        "aws_cloudhsm_v2_cluster": {
            "Tok": awsResource(MODS.cloudhsmv2Mod.value, "Cluster"),
            "Fields": {
                "cluster_state": {
                    "CsharpName": "State",
                },
            },
        },
        "aws_cloudhsm_v2_hsm": {
            "Tok": awsResource(MODS.cloudhsmv2Mod.value, "Hsm"),
            "Fields": {
                "hsm_state": {
                    "CsharpName": "State",
                },
            },
        },
        # CloudFront
        "aws_cloudfront_distribution": {
            "Tok": awsResource(MODS.cloudfrontMod.value, "Distribution")
        },
        "aws_cloudfront_public_key": {
            "Tok": awsResource(MODS.cloudfrontMod.value, "PublicKey")
        },
        "aws_cloudfront_origin_access_identity": {
            "Tok": awsResource(MODS.cloudfrontMod.value, "OriginAccessIdentity")
        },
        "aws_cloudfront_origin_request_policy": {
            "Tok": awsResource(MODS.cloudfrontMod.value, "OriginRequestPolicy")
        },
        "aws_cloudfront_cache_policy": {
            "Tok": awsResource(MODS.cloudfrontMod.value, "CachePolicy")
        },
        "aws_cloudfront_realtime_log_config": {
            "Tok": awsResource(MODS.cloudfrontMod.value, "RealtimeLogConfig")
        },
        "aws_cloudfront_key_group": {
            "Tok": awsResource(MODS.cloudfrontMod.value, "KeyGroup")
        },
        "aws_cloudfront_function": {
            "Tok": awsResource(MODS.cloudfrontMod.value, "Function")
        },
        "aws_cloudfront_monitoring_subscription": {
            "Tok": awsResource(MODS.cloudfrontMod.value, "MonitoringSubscription"),
            "Fields": {
                "monitoring_subscription": {
                    "CsharpName": "MonitoringSubscriptionDetails",
                },
            },
        },
        # CloudTrail
        "aws_cloudtrail": {"Tok": awsResource(MODS.cloudtrailMod.value, "Trail")},
        # CloudWatch
        "aws_cloudwatch_dashboard": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "Dashboard")
        },
        "aws_cloudwatch_event_permission": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "EventPermission")
        },
        "aws_cloudwatch_event_rule": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "EventRule"),
            "Fields": {
                "name": AutoName("name", 64, "-"),
            },
        },
        "aws_cloudwatch_event_target": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "EventTarget"),
            "Fields": {
                "target_id": AutoName("targetId", 255, "-"),
            },
        },
        "aws_cloudwatch_log_destination": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "LogDestination")
        },
        "aws_cloudwatch_log_destination_policy": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "LogDestinationPolicy")
        },
        "aws_cloudwatch_log_group": {
            "IDFields": ["name"],
            "Tok": awsResource(MODS.cloudwatchMod.value, "LogGroup"),
        },
        "aws_cloudwatch_log_metric_filter": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "LogMetricFilter")
        },
        "aws_cloudwatch_log_resource_policy": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "LogResourcePolicy"),
            "Fields": {
                "policy_document": {
                    "Elem": {
                        "Type": "string",
                        "AltTypes": [
                            awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                        ],
                        "Transform": TransformJSONDocument,
                    },
                },
            },
        },
        "aws_cloudwatch_log_stream": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "LogStream")
        },
        "aws_cloudwatch_event_bus": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "EventBus")
        },
        "aws_cloudwatch_composite_alarm": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "CompositeAlarm")
        },
        "aws_cloudwatch_event_archive": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "EventArchive")
        },
        "aws_cloudwatch_log_subscription_filter": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "LogSubscriptionFilter"),
            "Fields": {
                "log_group_name": {
                    "Name": "logGroup",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.cloudwatchMod.value, "LogGroup")],
                },
            },
            "DeleteBeforeReplace": True,  # only 1 active filter is legal at once
        },
        "aws_cloudwatch_metric_alarm": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "MetricAlarm"),
            "Fields": {
                "alarm_actions": {
                    "alarm_name": AutoName("name", 255, "-"),
                    "Elem": {
                        "Type": "string",
                        "AltTypes": [awsResource(MODS.snsMod.value, "Topic")],
                    },
                },
                "insufficient_data_actions": {
                    "Elem": {
                        "Type": "string",
                        "AltTypes": [awsResource(MODS.snsMod.value, "Topic")],
                    },
                },
                "ok_actions": {
                    "Elem": {
                        "Type": "string",
                        "AltTypes": [awsResource(MODS.snsMod.value, "Topic")],
                    },
                },
            },
        },
        "aws_cloudwatch_query_definition": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "QueryDefinition")
        },
        "aws_cloudwatch_metric_stream": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "MetricStream")
        },
        "aws_cloudwatch_event_api_destination": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "EventApiDestination")
        },
        "aws_cloudwatch_event_connection": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "EventConnection")
        },
        "aws_cloudwatch_event_bus_policy": {
            "Tok": awsResource(MODS.cloudwatchMod.value, "EventBusPolicy")
        },
        # CodeBuild
        "aws_codebuild_project": {
            "Tok": awsResource(MODS.codebuildMod.value, "Project")
        },
        "aws_codebuild_webhook": {
            "Tok": awsResource(MODS.codebuildMod.value, "Webhook")
        },
        "aws_codebuild_source_credential": {
            "Tok": awsResource(MODS.codebuildMod.value, "SourceCredential")
        },
        "aws_codebuild_report_group": {
            "Tok": awsResource(MODS.codebuildMod.value, "ReportGroup")
        },
        # CodeDeploy
        "aws_codedeploy_app": {
            "Tok": awsResource(MODS.codedeployMod.value, "Application")
        },
        "aws_codedeploy_deployment_config": {
            "Tok": awsResource(MODS.codedeployMod.value, "DeploymentConfig")
        },
        "aws_codedeploy_deployment_group": {
            "Tok": awsResource(MODS.codedeployMod.value, "DeploymentGroup")
        },
        # CodeCommit
        "aws_codecommit_repository": {
            "Tok": awsResource(MODS.codecommitMod.value, "Repository"),
            "Docs": {
                "Source": "code_commit_repository.html.markdown",
            },
        },
        "aws_codecommit_trigger": {
            "Tok": awsResource(MODS.codecommitMod.value, "Trigger"),
            "Docs": {
                "Source": "code_commit_trigger.html.markdown",
            },
        },
        # CodePipeline
        "aws_codepipeline": {
            "Tok": awsResource(MODS.codepipelineMod.value, "Pipeline"),
            "Fields": {
                "artifact_store": {
                    "MaxItemsOne": True,
                },
            },
        },
        "aws_codepipeline_webhook": {
            "Tok": awsResource(MODS.codepipelineMod.value, "Webhook")
        },
        # Cognito
        "aws_cognito_identity_pool": {
            "Tok": awsResource(MODS.cognitoMod.value, "IdentityPool")
        },
        "aws_cognito_identity_pool_roles_attachment": {
            "Tok": awsResource(MODS.cognitoMod.value, "IdentityPoolRoleAttachment")
        },
        "aws_cognito_identity_der": {
            "Tok": awsResource(MODS.cognitoMod.value, "Identityder")
        },
        "aws_cognito_resource_server": {
            "Tok": awsResource(MODS.cognitoMod.value, "ResourceServer")
        },
        "aws_cognito_user_group": {
            "Tok": awsResource(MODS.cognitoMod.value, "UserGroup")
        },
        "aws_cognito_user_pool": {
            "Tok": awsResource(MODS.cognitoMod.value, "UserPool")
        },
        "aws_cognito_user_pool_client": {
            "Tok": awsResource(MODS.cognitoMod.value, "UserPoolClient")
        },
        "aws_cognito_user_pool_domain": {
            "Tok": awsResource(MODS.cognitoMod.value, "UserPoolDomain")
        },
        "aws_cognito_user_pool_ui_customization": {
            "Tok": awsResource(MODS.cognitoMod.value, "UserPoolUICustomization")
        },
        # Connect
        "aws_connect_contact_flow": {
            "Tok": awsResource(MODS.connectMod.value, "ContactFlow")
        },
        "aws_connect_instance": {"Tok": awsResource(MODS.connectMod.value, "Instance")},
        # Config
        "aws_config_aggregate_authorization": {
            "Tok": awsResource(MODS.cfgMod.value, "AggregateAuthorization")
        },
        "aws_config_config_rule": {"Tok": awsResource(MODS.cfgMod.value, "Rule")},
        "aws_config_configuration_aggregator": {
            "Tok": awsResource(MODS.cfgMod.value, "ConfigurationAggregator")
        },
        "aws_config_configuration_recorder": {
            "Tok": awsResource(MODS.cfgMod.value, "Recorder")
        },
        "aws_config_configuration_recorder_status": {
            "Tok": awsResource(MODS.cfgMod.value, "RecorderStatus")
        },
        "aws_config_delivery_channel": {
            "Tok": awsResource(MODS.cfgMod.value, "DeliveryChannel")
        },
        "aws_config_organization_custom_rule": {
            "Tok": awsResource(MODS.cfgMod.value, "OrganizationCustomRule")
        },
        "aws_config_organization_managed_rule": {
            "Tok": awsResource(MODS.cfgMod.value, "OrganizationManagedRule")
        },
        "aws_config_remediation_configuration": {
            "Tok": awsResource(MODS.cfgMod.value, "RemediationConfiguration")
        },
        "aws_config_conformance_pack": {
            "Tok": awsResource(MODS.cfgMod.value, "ConformancePack")
        },
        "aws_config_organization_conformance_pack": {
            "Tok": awsResource(MODS.cfgMod.value, "OrganizationConformancePack")
        },
        # Cost and Usage Report
        "aws_cur_report_definition": {
            "Tok": awsResource(MODS.curMod.value, "ReportDefinition")
        },
        # DataSync
        "aws_datasync_agent": {"Tok": awsResource(MODS.datasyncMod.value, "Agent")},
        "aws_datasync_location_efs": {
            "Tok": awsResource(MODS.datasyncMod.value, "EfsLocation"),
            "Fields": {
                "efs_file_system_arn": {"Type": awsResource(MODS.awsMod.value, "ARN")},
            },
        },
        "aws_datasync_location_nfs": {
            "Tok": awsResource(MODS.datasyncMod.value, "NfsLocation")
        },
        "aws_datasync_location_s3": {
            "Tok": awsResource(MODS.datasyncMod.value, "S3Location"),
            "Fields": {
                "s3_bucket_arn": {"Type": awsResource(MODS.awsMod.value, "ARN")},
            },
        },
        "aws_datasync_task": {
            "Tok": awsResource(MODS.datasyncMod.value, "Task"),
            "Fields": {
                "destination_location_arn": {
                    "Type": awsResource(MODS.awsMod.value, "ARN")
                },
                "source_location_arn": {"Type": awsResource(MODS.awsMod.value, "ARN")},
                "cloudwatch_log_group_arn": {
                    "Type": awsResource(MODS.awsMod.value, "ARN")
                },
            },
        },
        "aws_datasync_location_smb": {
            "Tok": awsResource(MODS.datasyncMod.value, "LocationSmb")
        },
        "aws_datasync_location_fsx_windows_file_system": {
            "Tok": awsResource(MODS.datasyncMod.value, "LocationFsxWindows")
        },
        # Data Lifecycle Manager
        "aws_dlm_lifecycle_policy": {
            "Tok": awsResource(MODS.dlmMod.value, "LifecyclePolicy")
        },
        # Data Migration Service
        "aws_dms_certificate": {"Tok": awsResource(MODS.dmsMod.value, "Certificate")},
        "aws_dms_endpoint": {"Tok": awsResource(MODS.dmsMod.value, "Endpoint")},
        "aws_dms_replication_instance": {
            "Tok": awsResource(MODS.dmsMod.value, "ReplicationInstance")
        },
        "aws_dms_replication_subnet_group": {
            "Tok": awsResource(MODS.dmsMod.value, "ReplicationSubnetGroup")
        },
        "aws_dms_replication_task": {
            "Tok": awsResource(MODS.dmsMod.value, "ReplicationTask")
        },
        "aws_dms_event_subscription": {
            "Tok": awsResource(MODS.dmsMod.value, "EventSubscription")
        },
        # DAX
        "aws_dax_cluster": {"Tok": awsResource(MODS.daxMod.value, "Cluster")},
        "aws_dax_parameter_group": {
            "Tok": awsResource(MODS.daxMod.value, "ParameterGroup")
        },
        "aws_dax_subnet_group": {"Tok": awsResource(MODS.daxMod.value, "SubnetGroup")},
        # DeviceFarm
        "aws_devicefarm_project": {
            "Tok": awsResource(MODS.devicefarmMod.value, "Project")
        },
        # DirectoryService
        "aws_directory_service_conditional_forwarder": {
            "Tok": awsResource(MODS.directoryserviceMod.value, "ConditionalForwader")
        },
        "aws_directory_service_directory": {
            "Tok": awsResource(MODS.directoryserviceMod.value, "Directory"),
            "Fields": {
                "name": {"Name": "name"},
            },
        },
        "aws_directory_service_log_subscription": {
            "Tok": awsResource(MODS.directoryserviceMod.value, "LogService")
        },
        # Document DB
        "aws_docdb_cluster": {"Tok": awsResource(MODS.docdbMod.value, "Cluster")},
        "aws_docdb_cluster_instance": {
            "Tok": awsResource(MODS.docdbMod.value, "ClusterInstance")
        },
        "aws_docdb_cluster_parameter_group": {
            "Tok": awsResource(MODS.docdbMod.value, "ClusterParameterGroup")
        },
        "aws_docdb_cluster_snapshot": {
            "Tok": awsResource(MODS.docdbMod.value, "ClusterSnapshot")
        },
        "aws_docdb_subnet_group": {
            "Tok": awsResource(MODS.docdbMod.value, "SubnetGroup"),
            "Fields": {
                "description": {
                    "Default": managedByPulumi,
                },
            },
        },
        # Direct Connect
        "aws_dx_bgp_peer": {"Tok": awsResource(MODS.dxMod.value, "BgpPeer")},
        "aws_dx_connection": {"Tok": awsResource(MODS.dxMod.value, "Connection")},
        "aws_dx_connection_association": {
            "Tok": awsResource(MODS.dxMod.value, "ConnectionAssociation")
        },
        "aws_dx_gateway": {"Tok": awsResource(MODS.dxMod.value, "Gateway")},
        "aws_dx_gateway_association": {
            "Tok": awsResource(MODS.dxMod.value, "GatewayAssociation")
        },
        "aws_dx_gateway_association_proposal": {
            "Tok": awsResource(MODS.dxMod.value, "GatewayAssociationProposal")
        },
        "aws_dx_hosted_private_virtual_interface": {
            "Tok": awsResource(MODS.dxMod.value, "HostedPrivateVirtualInterface")
        },
        "aws_dx_hosted_private_virtual_interface_accepter": {
            "Tok": awsResource(
                MODS.dxMod.value, "HostedPrivateVirtualInterfaceAccepter"
            ),
        },
        "aws_dx_hosted_public_virtual_interface": {
            "Tok": awsResource(MODS.dxMod.value, "HostedPublicVirtualInterface")
        },
        "aws_dx_hosted_public_virtual_interface_accepter": {
            "Tok": awsResource(
                MODS.dxMod.value, "HostedPublicVirtualInterfaceAccepter"
            ),
        },
        "aws_dx_private_virtual_interface": {
            "Tok": awsResource(MODS.dxMod.value, "PrivateVirtualInterface")
        },
        "aws_dx_public_virtual_interface": {
            "Tok": awsResource(MODS.dxMod.value, "PublicVirtualInterface")
        },
        "aws_dx_lag": {"Tok": awsResource(MODS.dxMod.value, "LinkAggregationGroup")},
        "aws_dx_transit_virtual_interface": {
            "Tok": awsResource(MODS.dxMod.value, "TransitVirtualInterface")
        },
        "aws_dx_hosted_transit_virtual_interface": {
            "Tok": awsResource(MODS.dxMod.value, "HostedTransitVirtualInterface")
        },
        "aws_dx_hosted_transit_virtual_interface_accepter": {
            "Tok": awsResource(
                MODS.dxMod.value, "HostedTransitVirtualInterfaceAcceptor"
            ),
        },
        # DynamoDB
        "aws_dynamodb_global_table": {
            "Tok": awsResource(MODS.dynamodbMod.value, "GlobalTable")
        },
        "aws_dynamodb_table": {
            "Tok": awsResource(MODS.dynamodbMod.value, "Table"),
            "Fields": {
                # Override default pluralization ("indices") to match AWS APIs
                "global_secondary_index": {"Name": "globalSecondaryIndexes"},
                "local_secondary_index": {"Name": "localSecondaryIndexes"},
            },
        },
        "aws_dynamodb_table_item": {
            "Tok": awsResource(MODS.dynamodbMod.value, "TableItem")
        },
        "aws_dynamodb_kinesis_streaming_destination": {
            "Tok": awsResource(MODS.dynamodbMod.value, "KinesisStreamingDestination")
        },
        "aws_dynamodb_tag": {"Tok": awsResource(MODS.dynamodbMod.value, "Tag")},
        # Elastic Beanstalk
        "aws_elastic_beanstalk_application": {
            "Tok": awsResource(MODS.elasticbeanstalkMod.value, "Application")
        },
        "aws_elastic_beanstalk_application_version": {
            "Tok": awsResource(MODS.elasticbeanstalkMod.value, "ApplicationVersion"),
            "Fields": {
                "application": {
                    "Type": "string",
                    "AltTypes": [
                        awsResource(MODS.elasticbeanstalkMod.value, "Application")
                    ],
                },
                "bucket": {
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.s3Mod.value, "Bucket")],
                },
            },
        },
        "aws_elastic_beanstalk_configuration_template": {
            "Tok": awsResource(MODS.elasticbeanstalkMod.value, "ConfigurationTemplate")
        },
        "aws_elastic_beanstalk_environment": {
            "Tok": awsResource(MODS.elasticbeanstalkMod.value, "Environment"),
            "Fields": {
                "name": AutoName("name", 40, "-"),
                "application": {
                    "Type": "string",
                    "AltTypes": [
                        awsResource(MODS.elasticbeanstalkMod.value, "Application")
                    ],
                },
                "version_label": {
                    "Name": "version",
                    "Type": awsResource(
                        MODS.elasticbeanstalkMod.value, "ApplicationVersion"
                    ),
                },
            },
        },
        # Elastic Block Store
        "aws_ebs_default_kms_key": {
            "Tok": awsResource(MODS.ebsMod.value, "DefaultKmsKey")
        },
        "aws_ebs_encryption_by_default": {
            "Tok": awsResource(MODS.ebsMod.value, "EncryptionByDefault")
        },
        "aws_ebs_snapshot": {"Tok": awsResource(MODS.ebsMod.value, "Snapshot")},
        "aws_ebs_snapshot_copy": {
            "Tok": awsResource(MODS.ebsMod.value, "SnapshotCopy")
        },
        "aws_ebs_volume": {"Tok": awsResource(MODS.ebsMod.value, "Volume")},
        "aws_ebs_snapshot_import": {
            "Tok": awsResource(MODS.ebsMod.value, "SnapshotImport")
        },
        # ElastiCache
        "aws_elasticache_cluster": {
            "Tok": awsResource(MODS.elasticacheMod.value, "Cluster"),
            "Fields": {
                "cluster_id": AutoNameTransform("clusterId", 50, str.lower),
            },
        },
        "aws_elasticache_parameter_group": {
            "Tok": awsResource(MODS.elasticacheMod.value, "ParameterGroup"),
            "Fields": {
                "description": {
                    "Default": managedByPulumi,
                },
            },
        },
        "aws_elasticache_replication_group": {
            "Tok": awsResource(MODS.elasticacheMod.value, "ReplicationGroup"),
            "Fields": {
                "replication_group_id": AutoNameTransform(
                    "replicationGroupId", 40, str.lower
                ),
            },
        },
        "aws_elasticache_security_group": {
            "Tok": awsResource(MODS.elasticacheMod.value, "SecurityGroup"),
            "Fields": {
                "description": {"Default": managedByPulumi},
                # # Use "ingress" instead of "ingresses" to match AWS APIs
                # "ingress": {"Name": "ingress"},
            },
        },
        "aws_elasticache_subnet_group": {
            "Tok": awsResource(MODS.elasticacheMod.value, "SubnetGroup"),
            "Fields": {
                "description": {
                    "Default": managedByPulumi,
                },
            },
        },
        "aws_elasticache_global_replication_group": {
            "Tok": awsResource(MODS.elasticacheMod.value, "GlobalReplicationGroup")
        },
        "aws_elasticache_user": {"Tok": awsResource(MODS.elasticacheMod.value, "User")},
        "aws_elasticache_user_group": {
            "Tok": awsResource(MODS.elasticacheMod.value, "UserGroup")
        },
        # Elastic Compute (EC2)
        "aws_ami": {
            "Tok": awsResource(MODS.ec2Mod.value, "Ami"),
        },
        "aws_ami_copy": {
            "Tok": awsResource(MODS.ec2Mod.value, "AmiCopy"),
            "Docs": {
                "IncludeArgumentsFrom": "aws_ami",
                "IncludeAttributesFromArguments": "aws_ami",
            },
        },
        "aws_ami_from_instance": {
            "Tok": awsResource(MODS.ec2Mod.value, "AmiFromInstance"),
            "Docs": {
                "IncludeAttributesFromArguments": "aws_ami",
            },
        },
        "aws_ami_launch_permission": {
            "Tok": awsResource(MODS.ec2Mod.value, "AmiLaunchPermission")
        },
        "aws_customer_gateway": {
            "Tok": awsResource(MODS.ec2Mod.value, "CustomerGateway")
        },
        "aws_egress_only_internet_gateway": {
            "Tok": awsResource(MODS.ec2Mod.value, "EgressOnlyInternetGateway")
        },
        "aws_eip": {"Tok": awsResource(MODS.ec2Mod.value, "Eip")},
        "aws_eip_association": {
            "Tok": awsResource(MODS.ec2Mod.value, "EipAssociation")
        },
        "aws_flow_log": {"Tok": awsResource(MODS.ec2Mod.value, "FlowLog")},
        "aws_instance": {
            "Tok": awsResource(MODS.ec2Mod.value, "Instance"),
            "Fields": {
                "iam_instance_profile": {
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.iamMod.value, "InstanceProfile")],
                },
                "instance_type": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.ec2Mod.value, "InstanceType", "InstanceType")
                    ],
                },
                "instance_state": {
                    "CsharpName": "State",
                },
                "security_groups": {
                    "DeprecationMessage": (
                        "Use of `securityGroups` is discouraged as it does not allow "
                        "for changes and will force your instance to be replaced if "
                        "changes are made. To avoid this, use `vpcSecurityGroupIds` "
                        "which allows for updates."
                    ),
                },
                "tenancy": {
                    "Type": "string",
                    "AltTypes": [awsType(MODS.ec2Mod.value, "Tenancy", "Tenancy")],
                },
            },
        },
        "aws_internet_gateway": {
            "Tok": awsResource(MODS.ec2Mod.value, "InternetGateway")
        },
        "aws_key_pair": {
            "Tok": awsResource(MODS.ec2Mod.value, "KeyPair"),
            "Fields": {
                "key_name": AutoName("keyName", 255, "-"),
            },
        },
        "aws_launch_configuration": {
            "Tok": awsResource(MODS.ec2Mod.value, "LaunchConfiguration"),
            "Fields": {
                "iam_instance_profile": {
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.iamMod.value, "InstanceProfile")],
                },
            },
        },
        "aws_launch_template": {
            "Tok": awsResource(MODS.ec2Mod.value, "LaunchTemplate")
        },
        "aws_main_route_table_association": {
            "Tok": awsResource(MODS.ec2Mod.value, "MainRouteTableAssociation"),
            "Docs": {
                "Source": "main_route_table_assoc.html.markdown",
            },
        },
        "aws_nat_gateway": {"Tok": awsResource(MODS.ec2Mod.value, "NatGateway")},
        "aws_network_acl": {
            "Tok": awsResource(MODS.ec2Mod.value, "NetworkAcl"),
            "Fields": {
                # Use "ingress" instead of "ingresses" to match AWS APIs
                "ingress": {"Name": "ingress"},
                "egress": {"Name": "egress"},
            },
        },
        "aws_default_network_acl": {
            "Tok": awsResource(MODS.ec2Mod.value, "DefaultNetworkAcl"),
            "Fields": {
                # Use "ingress" instead of "ingresses" to match AWS APIs
                "ingress": {"Name": "ingress"},
                "egress": {"Name": "egress"},
            },
        },
        "aws_network_acl_rule": {
            "Tok": awsResource(MODS.ec2Mod.value, "NetworkAclRule")
        },
        "aws_network_interface": {
            "Tok": awsResource(MODS.ec2Mod.value, "NetworkInterface")
        },
        "aws_network_interface_attachment": {
            "Tok": awsResource(MODS.ec2Mod.value, "NetworkInterfaceAttachment")
        },
        "aws_placement_group": {
            "Tok": awsResource(MODS.ec2Mod.value, "PlacementGroup"),
            "Fields": {
                "strategy": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(
                            MODS.ec2Mod.value, "PlacementStrategy", "PlacementStrategy"
                        )
                    ],
                },
            },
        },
        "aws_proxy_protocol_policy": {
            "Tok": awsResource(MODS.ec2Mod.value, "ProxyProtocolPolicy")
        },
        "aws_route": {"Tok": awsResource(MODS.ec2Mod.value, "Route")},
        "aws_route_table": {"Tok": awsResource(MODS.ec2Mod.value, "RouteTable")},
        "aws_default_route_table": {
            "Tok": awsResource(MODS.ec2Mod.value, "DefaultRouteTable")
        },
        "aws_ec2_capacity_reservation": {
            "Tok": awsResource(MODS.ec2Mod.value, "CapacityReservation"),
            "Fields": {
                "instance_type": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.ec2Mod.value, "InstanceType", "InstanceType")
                    ],
                },
                "instance_platform": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(
                            MODS.ec2Mod.value, "InstancePlatform", "InstancePlatform"
                        )
                    ],
                },
                "tenancy": {
                    "Type": "string",
                    "AltTypes": [awsType(MODS.ec2Mod.value, "Tenancy", "Tenancy")],
                },
            },
        },
        "aws_ec2_fleet": {"Tok": awsResource(MODS.ec2Mod.value, "Fleet")},
        "aws_route_table_association": {
            "Tok": awsResource(MODS.ec2Mod.value, "RouteTableAssociation")
        },
        "aws_security_group": {
            "Tok": awsResource(MODS.ec2Mod.value, "SecurityGroup"),
            "Fields": {
                "description": {"Default": managedByPulumi},
                # Use "ingress" instead of "ingresses" to match AWS APIs
                "ingress": {"Name": "ingress"},
                "egress": {"Name": "egress"},
            },
        },
        "aws_network_interface_sg_attachment": {
            "Tok": awsResource(
                MODS.ec2Mod.value, "NetworkInterfaceSecurityGroupAttachment"
            )
        },
        "aws_default_security_group": {
            "Tok": awsResource(MODS.ec2Mod.value, "DefaultSecurityGroup"),
            "Fields": {
                # Use "ingress" instead of "ingresses" to match AWS APIs
                "ingress": {"Name": "ingress"},
                "egress": {"Name": "egress"},
            },
        },
        "aws_security_group_rule": {
            "Tok": awsResource(MODS.ec2Mod.value, "SecurityGroupRule"),
            "Fields": {
                "protocol": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.ec2Mod.value, "ProtocolType", "ProtocolType")
                    ],
                },
            },
        },
        "aws_snapshot_create_volume_permission": {
            "Tok": awsResource(MODS.ec2Mod.value, "SnapshotCreateVolumePermission")
        },
        "aws_spot_datafeed_subscription": {
            "Tok": awsResource(MODS.ec2Mod.value, "SpotDatafeedSubscription")
        },
        "aws_spot_instance_request": {
            "Tok": awsResource(MODS.ec2Mod.value, "SpotInstanceRequest"),
            "Docs": {
                "IncludeArgumentsFrom": "aws_instance",
            },
        },
        "aws_spot_fleet_request": {
            "Tok": awsResource(MODS.ec2Mod.value, "SpotFleetRequest")
        },
        "aws_default_subnet": {"Tok": awsResource(MODS.ec2Mod.value, "DefaultSubnet")},
        "aws_subnet": {"Tok": awsResource(MODS.ec2Mod.value, "Subnet")},
        "aws_volume_attachment": {
            "Tok": awsResource(MODS.ec2Mod.value, "VolumeAttachment")
        },
        "aws_vpc_dhcp_options_association": {
            "Tok": awsResource(MODS.ec2Mod.value, "VpcDhcpOptionsAssociation")
        },
        "aws_default_vpc_dhcp_options": {
            "Tok": awsResource(MODS.ec2Mod.value, "DefaultVpcDhcpOptions")
        },
        "aws_vpc_dhcp_options": {
            "Tok": awsResource(MODS.ec2Mod.value, "VpcDhcpOptions")
        },
        "aws_vpc_peering_connection": {
            "Tok": awsResource(MODS.ec2Mod.value, "VpcPeeringConnection"),
            "Docs": {
                "Source": "vpc_peering.html.markdown",
            },
        },
        "aws_vpc_peering_connection_accepter": {
            "Tok": awsResource(MODS.ec2Mod.value, "VpcPeeringConnectionAccepter"),
            "Docs": {
                "Source": "vpc_peering_accepter.html.markdown",
            },
        },
        "aws_vpc_peering_connection_options": {
            "Tok": awsResource(MODS.ec2Mod.value, "PeeringConnectionOptions"),
            "Docs": {
                "Source": "vpc_peering_options.html.markdown",
            },
        },
        "aws_default_vpc": {"Tok": awsResource(MODS.ec2Mod.value, "DefaultVpc")},
        "aws_vpc": {"Tok": awsResource(MODS.ec2Mod.value, "Vpc")},
        "aws_vpc_endpoint": {"Tok": awsResource(MODS.ec2Mod.value, "VpcEndpoint")},
        "aws_vpc_endpoint_connection_notification": {
            "Tok": awsResource(MODS.ec2Mod.value, "VpcEndpointConnectionNotification")
        },
        "aws_vpc_endpoint_route_table_association": {
            "Tok": awsResource(MODS.ec2Mod.value, "VpcEndpointRouteTableAssociation")
        },
        "aws_vpc_endpoint_service": {
            "Tok": awsResource(MODS.ec2Mod.value, "VpcEndpointService")
        },
        "aws_vpc_endpoint_service_allowed_principal": {
            "Tok": awsResource(MODS.ec2Mod.value, "VpcEndpointServiceAllowedPrinciple")
        },
        "aws_vpc_endpoint_subnet_association": {
            "Tok": awsResource(MODS.ec2Mod.value, "VpcEndpointSubnetAssociation")
        },
        "aws_vpc_ipv4_cidr_block_association": {
            "Tok": awsResource(MODS.ec2Mod.value, "VpcIpv4CidrBlockAssociation")
        },
        "aws_vpn_connection": {"Tok": awsResource(MODS.ec2Mod.value, "VpnConnection")},
        "aws_vpn_connection_route": {
            "Tok": awsResource(MODS.ec2Mod.value, "VpnConnectionRoute")
        },
        "aws_vpn_gateway": {"Tok": awsResource(MODS.ec2Mod.value, "VpnGateway")},
        "aws_vpn_gateway_attachment": {
            "Tok": awsResource(MODS.ec2Mod.value, "VpnGatewayAttachment")
        },
        "aws_vpn_gateway_route_propagation": {
            "Tok": awsResource(MODS.ec2Mod.value, "VpnGatewayRoutePropagation")
        },
        "aws_ec2_traffic_mirror_filter": {
            "Tok": awsResource(MODS.ec2Mod.value, "TrafficMirrorFilter")
        },
        "aws_ec2_traffic_mirror_filter_rule": {
            "Tok": awsResource(MODS.ec2Mod.value, "TrafficMirrorFilterRule")
        },
        "aws_ec2_traffic_mirror_session": {
            "Tok": awsResource(MODS.ec2Mod.value, "TrafficMirrorSession")
        },
        "aws_ec2_traffic_mirror_target": {
            "Tok": awsResource(MODS.ec2Mod.value, "TrafficMirrorTarget")
        },
        "aws_ec2_availability_zone_group": {
            "Tok": awsResource(MODS.ec2Mod.value, "AvailabilityZoneGroup")
        },
        "aws_ec2_transit_gateway_peering_attachment_accepter": {
            "Tok": awsResource(
                MODS.ec2Mod.value, "TransitGatewayPeeringAttachmentAccepter"
            ),
        },
        "aws_ec2_local_gateway_route": {
            "Tok": awsResource(MODS.ec2Mod.value, "LocalGatewayRoute")
        },
        "aws_ec2_local_gateway_route_table_vpc_association": {
            "Tok": awsResource(
                MODS.ec2Mod.value, "LocalGatewayRouteTableVpcAssociation"
            ),
        },
        "aws_ec2_tag": {"Tok": awsResource(MODS.ec2Mod.value, "Tag")},
        "aws_dedicated_host": {"Tok": awsResource(MODS.ec2Mod.value, "DedicatedHost")},
        "aws_ec2_managed_prefix_list": {
            "Tok": awsResource(MODS.ec2Mod.value, "ManagedPrefixList")
        },
        "aws_ec2_carrier_gateway": {
            "Tok": awsResource(MODS.ec2Mod.value, "CarrierGateway")
        },
        "aws_ec2_managed_prefix_list_entry": {
            "Tok": awsResource(MODS.ec2Mod.value, "ManagedPrefixListEntry")
        },
        # EC2 Client VPN
        "aws_ec2_client_vpn_endpoint": {
            "Tok": awsResource(MODS.ec2ClientVpnMod.value, "Endpoint")
        },
        "aws_ec2_client_vpn_network_association": {
            "Tok": awsResource(MODS.ec2ClientVpnMod.value, "NetworkAssociation")
        },
        "aws_ec2_client_vpn_authorization_rule": {
            "Tok": awsResource(MODS.ec2ClientVpnMod.value, "AuthorizationRule")
        },
        "aws_ec2_client_vpn_route": {
            "Tok": awsResource(MODS.ec2ClientVpnMod.value, "Route")
        },
        # EC2 Transit Gateway
        "aws_ec2_transit_gateway": {
            "Tok": awsResource(MODS.ec2TransitGatewayMod.value, "TransitGateway"),
            "Fields": {
                "arn": {"Type": awsResource(MODS.awsMod.value, "ARN")},
            },
        },
        "aws_ec2_transit_gateway_route": {
            "Tok": awsResource(MODS.ec2TransitGatewayMod.value, "Route"),
        },
        "aws_ec2_transit_gateway_route_table": {
            "Tok": awsResource(MODS.ec2TransitGatewayMod.value, "RouteTable")
        },
        "aws_ec2_transit_gateway_prefix_list_reference": {
            "Tok": awsResource(MODS.ec2TransitGatewayMod.value, "PrefixListReference")
        },
        "aws_ec2_transit_gateway_route_table_association": {
            "Tok": awsResource(
                MODS.ec2TransitGatewayMod.value, "RouteTableAssociation"
            ),
        },
        "aws_ec2_transit_gateway_route_table_propagation": {
            "Tok": awsResource(
                MODS.ec2TransitGatewayMod.value, "RouteTablePropagation"
            ),
        },
        "aws_ec2_transit_gateway_vpc_attachment": {
            "Tok": awsResource(MODS.ec2TransitGatewayMod.value, "VpcAttachment")
        },
        "aws_ec2_transit_gateway_vpc_attachment_accepter": {
            "Tok": awsResource(MODS.ec2TransitGatewayMod.value, "VpcAttachmentAccepter")
        },
        "aws_ec2_transit_gateway_peering_attachment": {
            "Tok": awsResource(MODS.ec2TransitGatewayMod.value, "PeeringAttachment")
        },
        # Elastic Container Registry
        "aws_ecr_repository": {"Tok": awsResource(MODS.ecrMod.value, "Repository")},
        "aws_ecr_repository_policy": {
            "Tok": awsResource(MODS.ecrMod.value, "RepositoryPolicy"),
            "Fields": {
                "policy": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                    ],
                    "Transform": TransformJSONDocument,
                },
            },
        },
        "aws_ecr_lifecycle_policy": {
            "Tok": awsResource(MODS.ecrMod.value, "LifecyclePolicy"),
            "Fields": {
                "policy": {
                    "Type": "string",
                    "AltTypes": [
                        awsResource(MODS.ecrMod.value, "LifecyclePolicyDocument")
                    ],
                    "Transform": TransformJSONDocument,
                },
            },
        },
        "aws_ecr_registry_policy": {
            "Tok": awsResource(MODS.ecrMod.value, "RegistryPolicy"),
            "Fields": {
                "policy": {
                    "Elem": {
                        "Type": "string",
                        "AltTypes": [
                            awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                        ],
                        "Transform": TransformJSONDocument,
                    },
                },
            },
        },
        "aws_ecr_replication_configuration": {
            "Tok": awsResource(MODS.ecrMod.value, "ReplicationConfiguration"),
            "Fields": {
                "replication_configuration": {
                    "CsharpName": "ReplicationConfigurationDetails",
                },
            },
        },
        # ecr public
        "aws_ecrpublic_repository": {
            "Tok": awsResource(MODS.ecrPublicMod.value, "Repository")
        },
        # Elastic Container Service
        "aws_ecs_cluster": {"Tok": awsResource(MODS.ecsMod.value, "Cluster")},
        "aws_ecs_service": {
            "Tok": awsResource(MODS.ecsMod.value, "Service"),
            "Fields": {
                "load_balancer": {
                    # Even though only one is currently supported, the AWS API is designed to support multiple, so
                    # force this to project as an array (and assign a plural name).
                    "Name": "loadBalancers",
                    "MaxItemsOne": False,
                },
            },
        },
        "aws_ecs_task_definition": {
            "Tok": awsResource(MODS.ecsMod.value, "TaskDefinition")
        },
        "aws_ecs_capacity_der": {"Tok": awsResource(MODS.ecsMod.value, "Capacityder")},
        "aws_ecs_tag": {"Tok": awsResource(MODS.ecsMod.value, "Tag")},
        # Elastic File System
        "aws_efs_file_system": {
            "Tok": awsResource(MODS.efsMod.value, "FileSystem"),
            "Fields": {
                "creation_token": AutoName("creationToken", 255, "-"),
                "lifecycle_policy": {
                    "MaxItemsOne": True,
                },
            },
        },
        "aws_efs_mount_target": {
            "Tok": awsResource(MODS.efsMod.value, "MountTarget"),
            "DeleteBeforeReplace": True,  # only 1 mount target per AZ.
        },
        "aws_efs_access_point": {"Tok": awsResource(MODS.efsMod.value, "AccessPoint")},
        "aws_efs_file_system_policy": {
            "Tok": awsResource(MODS.efsMod.value, "FileSystemPolicy")
        },
        "aws_efs_backup_policy": {
            "Tok": awsResource(MODS.efsMod.value, "BackupPolicy"),
            "Fields": {
                "backup_policy": {
                    "CsharpName": "BackupPolicyDetails",
                },
            },
        },
        # ECS for Kubernetes
        "aws_eks_cluster": {
            "Tok": awsResource(MODS.eksMod.value, "Cluster"),
            "Fields": {
                "certificate_authority": {
                    "MaxItemsOne": True,
                },
            },
        },
        "aws_eks_node_group": {
            "Tok": awsResource(MODS.eksMod.value, "NodeGroup"),
            "Fields": {
                "node_group_name": AutoName("nodeGroupName", 255, "-"),
            },
        },
        "aws_eks_fargate_profile": {
            "Tok": awsResource(MODS.eksMod.value, "FargateProfile"),
            "Fields": {
                "fargate_profile_name": AutoName("fargateProfileName", 255, "-"),
            },
        },
        "aws_eks_addon": {"Tok": awsResource(MODS.eksMod.value, "Addon")},
        "aws_eks_identity_der_config": {
            "Tok": awsResource(MODS.eksMod.value, "IdentityderConfig")
        },
        # Elastic Search
        "aws_elasticsearch_domain": {
            "Tok": awsResource(MODS.elasticsearchMod.value, "Domain"),
            "Fields": {
                "domain_name": AutoNameTransform(
                    "domainName", 28, lambda name: name.lower()
                ),
                "cluster_config": {"Name": "clusterConfig"},
                "ebs_options": {"Name": "ebsOptions"},
                "snapshot_options": {"Name": "snapshotOptions"},
                "access_policies": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                    ],
                    "Transform": TransformJSONDocument,
                },
            },
        },
        "aws_elasticsearch_domain_policy": {
            "Tok": awsResource(MODS.elasticsearchMod.value, "DomainPolicy"),
            "Fields": {
                "access_policies": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                    ],
                    "Transform": TransformJSONDocument,
                },
            },
        },
        "aws_elasticsearch_domain_saml_options": {
            "Tok": awsResource(MODS.elasticsearchMod.value, "DomainSamlOptions")
        },
        # Elastic Transcoder
        "aws_elastictranscoder_pipeline": {
            "Tok": awsResource(MODS.elastictranscoderMod.value, "Pipeline"),
            "Docs": {
                "Source": "elastic_transcoder_pipeline.html.markdown",
            },
        },
        "aws_elastictranscoder_preset": {
            "Tok": awsResource(MODS.elastictranscoderMod.value, "Preset"),
            "Docs": {
                "Source": "elastic_transcoder_preset.html.markdown",
            },
        },
        # Elastic MapReduce
        "aws_emr_cluster": {
            "Tok": awsResource(MODS.emrMod.value, "Cluster"),
            "Fields": {
                "cluster_state": {
                    "CsharpName": "State",
                },
            },
        },
        "aws_emr_instance_group": {
            "Tok": awsResource(MODS.emrMod.value, "InstanceGroup")
        },
        "aws_emr_security_configuration": {
            "Tok": awsResource(MODS.emrMod.value, "SecurityConfiguration")
        },
        "aws_emr_managed_scaling_policy": {
            "Tok": awsResource(MODS.emrMod.value, "ManagedScalingPolicy")
        },
        "aws_emr_instance_fleet": {
            "Tok": awsResource(MODS.emrMod.value, "InstanceFleet")
        },
        # FSX
        "aws_fsx_lustre_file_system": {
            "Tok": awsResource(MODS.fsxMod.value, "LustreFileSystem")
        },
        "aws_fsx_windows_file_system": {
            "Tok": awsResource(MODS.fsxMod.value, "WindowsFileSystem")
        },
        "aws_fsx_backup": {"Tok": awsResource(MODS.fsxMod.value, "Backup")},
        "aws_fsx_ontap_file_system": {
            "Tok": awsResource(MODS.fsxMod.value, "OntapFileSystem")
        },
        # GameLift
        "aws_gamelift_alias": {"Tok": awsResource(MODS.gameliftMod.value, "Alias")},
        "aws_gamelift_build": {"Tok": awsResource(MODS.gameliftMod.value, "Build")},
        "aws_gamelift_fleet": {"Tok": awsResource(MODS.gameliftMod.value, "Fleet")},
        "aws_gamelift_game_session_queue": {
            "Tok": awsResource(MODS.gameliftMod.value, "GameSessionQueue")
        },
        # Glacier
        "aws_glacier_vault": {"Tok": awsResource(MODS.glacierMod.value, "Vault")},
        "aws_glacier_vault_lock": {
            "Tok": awsResource(MODS.glacierMod.value, "VaultLock")
        },
        # Global Accelerator
        "aws_globalaccelerator_accelerator": {
            "Tok": awsResource(MODS.globalacceleratorMod.value, "Accelerator")
        },
        "aws_globalaccelerator_endpoint_group": {
            "Tok": awsResource(MODS.globalacceleratorMod.value, "EndpointGroup")
        },
        "aws_globalaccelerator_listener": {
            "Tok": awsResource(MODS.globalacceleratorMod.value, "Listener")
        },
        # Glue
        "aws_glue_catalog_database": {
            "Tok": awsResource(MODS.glueMod.value, "CatalogDatabase"),
            "Fields": {
                "name": {
                    "Default": {
                        # This means the name will adhere to ^[a-z]+(_[a-z]+)*$  as per
                        # https:#docs.aws.amazon.com/athena/latest/ug/tables-databases-columns-names.html
                        # From: FromName(AutoNameOptions{
                        #     Transform: func(name string) string {
                        #         newName := fmt.Sprintf("%s_%s", name, transformWithRandomString(8))
                        #         return strings.ToLower(newName)
                        #     },
                        # }),
                    },
                },
            },
        },
        "aws_glue_catalog_table": {
            "Tok": awsResource(MODS.glueMod.value, "CatalogTable"),
            "Fields": {
                "name": {
                    "Default": {
                        # This means the name will adhere to ^[a-z]+(_[a-z]+)*$  as per
                        # https:#docs.aws.amazon.com/athena/latest/ug/tables-databases-columns-names.html
                        # From: FromName(AutoNameOptions{
                        #     Transform: func(name string) string {
                        #         newName := fmt.Sprintf("%s_%s", name, transformWithRandomString(8))
                        #         return strings.ToLower(newName)
                        #     },
                        # }),
                    },
                },
            },
        },
        "aws_glue_classifier": {"Tok": awsResource(MODS.glueMod.value, "Classifier")},
        "aws_glue_connection": {"Tok": awsResource(MODS.glueMod.value, "Connection")},
        "aws_glue_crawler": {"Tok": awsResource(MODS.glueMod.value, "Crawler")},
        "aws_glue_job": {"Tok": awsResource(MODS.glueMod.value, "Job")},
        "aws_glue_security_configuration": {
            "Tok": awsResource(MODS.glueMod.value, "SecurityConfiguration")
        },
        "aws_glue_trigger": {"Tok": awsResource(MODS.glueMod.value, "Trigger")},
        "aws_glue_workflow": {"Tok": awsResource(MODS.glueMod.value, "Workflow")},
        "aws_glue_user_defined_function": {
            "Tok": awsResource(MODS.glueMod.value, "UserDefinedFunction")
        },
        "aws_glue_data_catalog_encryption_settings": {
            "Tok": awsResource(MODS.glueMod.value, "DataCatalogEncryptionSettings"),
            "Fields": {
                "data_catalog_encryption_settings": {
                    "CsharpName": "DataCatalogEncryptionSettingsConfig",
                },
            },
        },
        "aws_glue_ml_transform": {
            "Tok": awsResource(MODS.glueMod.value, "MLTransform")
        },
        "aws_glue_partition": {"Tok": awsResource(MODS.glueMod.value, "Partition")},
        "aws_glue_resource_policy": {
            "Tok": awsResource(MODS.glueMod.value, "ResourcePolicy")
        },
        "aws_glue_dev_endpoint": {
            "Tok": awsResource(MODS.glueMod.value, "DevEndpoint")
        },
        "aws_glue_registry": {"Tok": awsResource(MODS.glueMod.value, "Registry")},
        "aws_glue_schema": {"Tok": awsResource(MODS.glueMod.value, "Schema")},
        # GuardDuty
        "aws_guardduty_detector": {
            "Tok": awsResource(MODS.guarddutyMod.value, "Detector")
        },
        "aws_guardduty_invite_accepter": {
            "Tok": awsResource(MODS.guarddutyMod.value, "InviteAccepter")
        },
        "aws_guardduty_ipset": {"Tok": awsResource(MODS.guarddutyMod.value, "IPSet")},
        "aws_guardduty_member": {"Tok": awsResource(MODS.guarddutyMod.value, "Member")},
        "aws_guardduty_threatintelset": {
            "Tok": awsResource(MODS.guarddutyMod.value, "ThreatIntelSet")
        },
        "aws_guardduty_organization_admin_account": {
            "Tok": awsResource(MODS.guarddutyMod.value, "OrganizationAdminAccount")
        },
        "aws_guardduty_organization_configuration": {
            "Tok": awsResource(MODS.guarddutyMod.value, "OrganizationConfiguration")
        },
        "aws_guardduty_publishing_destination": {
            "Tok": awsResource(MODS.guarddutyMod.value, "PublishingDestination")
        },
        "aws_guardduty_filter": {"Tok": awsResource(MODS.guarddutyMod.value, "Filter")},
        # Identity and Access Management (IAM)
        "aws_iam_access_key": {"Tok": awsResource(MODS.iamMod.value, "AccessKey")},
        "aws_iam_account_alias": {
            "Tok": awsResource(MODS.iamMod.value, "AccountAlias"),
            "Fields": {
                "account_alias": {
                    "CsharpName": "Alias",
                },
            },
        },
        "aws_iam_account_password_policy": {
            "Tok": awsResource(MODS.iamMod.value, "AccountPasswordPolicy")
        },
        "aws_iam_group_policy": {
            "Tok": awsResource(MODS.iamMod.value, "GroupPolicy"),
            "Fields": {
                "policy": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                    ],
                    "Transform": TransformJSONDocument,
                },
            },
        },
        "aws_iam_group": {"Tok": awsResource(MODS.iamMod.value, "Group")},
        "aws_iam_group_membership": {
            "Tok": awsResource(MODS.iamMod.value, "GroupMembership")
        },
        "aws_iam_group_policy_attachment": {
            "Tok": awsResource(MODS.iamMod.value, "GroupPolicyAttachment"),
            "Fields": {
                "group": {
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.iamMod.value, "Group")],
                },
                "policy_arn": {
                    "Name": "policyArn",
                    "Type": awsResource(MODS.awsMod.value, "ARN"),
                },
            },
            # We pass delete-before-replace: this is a leaf node and a create followed by a delete actually
            # deletes the same attachment we just created, since it is structurally equivalent!
            "DeleteBeforeReplace": True,
        },
        "aws_iam_instance_profile": {
            "Tok": awsResource(MODS.iamMod.value, "InstanceProfile"),
            "Fields": {
                "role": {
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.iamMod.value, "Role")],
                },
            },
        },
        "aws_iam_openid_connect_der": {
            "Tok": awsResource(MODS.iamMod.value, "OpenIdConnectder")
        },
        "aws_iam_policy": {
            "Tok": awsResource(MODS.iamMod.value, "Policy"),
            "Fields": {
                "policy": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                    ],
                    "Transform": TransformJSONDocument,
                    "CsharpName": "PolicyDocument",
                },
            },
        },
        "aws_iam_policy_attachment": {
            "Tok": awsResource(MODS.iamMod.value, "PolicyAttachment"),
            "Fields": {
                "users": {
                    "Elem": {
                        "Type": "string",
                        "AltTypes": [awsResource(MODS.iamMod.value, "User")],
                    },
                },
                "roles": {
                    "Elem": {
                        "Type": "string",
                        "AltTypes": [awsResource(MODS.iamMod.value, "Role")],
                    },
                },
                "groups": {
                    "Elem": {
                        "Type": "string",
                        "AltTypes": [awsResource(MODS.iamMod.value, "Group")],
                    },
                },
                "policy_arn": {
                    "Name": "policyArn",
                    "Type": awsResource(MODS.awsMod.value, "ARN"),
                },
            },
            # We pass delete-before-replace: this is a leaf node and a create followed by a delete actually
            # deletes the same attachment we just created, since it is structurally equivalent!
            "DeleteBeforeReplace": True,
        },
        "aws_iam_role_policy_attachment": {
            "Tok": awsResource(MODS.iamMod.value, "RolePolicyAttachment"),
            "Fields": {
                "role": {
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.iamMod.value, "Role")],
                },
                "policy_arn": {
                    "Name": "policyArn",
                    "Type": awsResource(MODS.awsMod.value, "ARN"),
                },
            },
            # We pass delete-before-replace: this is a leaf node and a create followed by a delete actually
            # deletes the same attachment we just created, since it is structurally equivalent!
            "DeleteBeforeReplace": True,
        },
        "aws_iam_role_policy": {
            "Tok": awsResource(MODS.iamMod.value, "RolePolicy"),
            "Fields": {
                "role": {
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.iamMod.value, "Role")],
                },
                "policy": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                    ],
                    "Transform": TransformJSONDocument,
                },
            },
        },
        "aws_iam_role": {
            "Tok": awsResource(MODS.iamMod.value, "Role"),
            "Fields": {
                "name": AutoName("name", 64, "-"),
                "assume_role_policy": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                    ],
                    "Transform": TransformJSONDocument,
                },
            },
        },
        "aws_iam_saml_der": {"Tok": awsResource(MODS.iamMod.value, "Samlder")},
        "aws_iam_server_certificate": {
            "Tok": awsResource(MODS.iamMod.value, "ServerCertificate")
        },
        "aws_iam_service_linked_role": {
            "Tok": awsResource(MODS.iamMod.value, "ServiceLinkedRole")
        },
        "aws_iam_user_group_membership": {
            "Tok": awsResource(MODS.iamMod.value, "UserGroupMembership")
        },
        "aws_iam_user_policy_attachment": {
            "Tok": awsResource(MODS.iamMod.value, "UserPolicyAttachment"),
            "Fields": {
                "user": {
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.iamMod.value, "User")],
                },
                "policy_arn": {
                    "Name": "policyArn",
                    "Type": awsResource(MODS.awsMod.value, "ARN"),
                },
            },
            # We pass delete-before-replace: this is a leaf node and a create followed by a delete actually
            # deletes the same attachment we just created, since it is structurally equivalent!
            "DeleteBeforeReplace": True,
        },
        "aws_iam_user_policy": {
            "Tok": awsResource(MODS.iamMod.value, "UserPolicy"),
            "Fields": {
                "policy": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                    ],
                    "Transform": TransformJSONDocument,
                },
            },
        },
        "aws_iam_user_ssh_key": {"Tok": awsResource(MODS.iamMod.value, "SshKey")},
        "aws_iam_user": {"Tok": awsResource(MODS.iamMod.value, "User")},
        "aws_iam_user_login_profile": {
            "Tok": awsResource(MODS.iamMod.value, "UserLoginProfile")
        },
        # Inspector
        "aws_inspector_assessment_target": {
            "Tok": awsResource(MODS.inspectorMod.value, "AssessmentTarget")
        },
        "aws_inspector_assessment_template": {
            "Tok": awsResource(MODS.inspectorMod.value, "AssessmentTemplate")
        },
        "aws_inspector_resource_group": {
            "Tok": awsResource(MODS.inspectorMod.value, "ResourceGroup")
        },
        # IOT
        "aws_iot_certificate": {"Tok": awsResource(MODS.iotMod.value, "Certificate")},
        "aws_iot_policy": {
            "Tok": awsResource(MODS.iotMod.value, "Policy"),
            "IDFields": ["name"],
            "Fields": {
                "policy": {
                    "CsharpName": "PolicyDocument",
                },
            },
        },
        "aws_iot_policy_attachment": {
            "Tok": awsResource(MODS.iotMod.value, "PolicyAttachment"),
            "Fields": {
                "policy": {
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.iotMod.value, "Policy")],
                },
                "target": {
                    "Type": awsResource(MODS.awsMod.value, "ARN"),
                },
            },
        },
        "aws_iot_role_alias": {"Tok": awsResource(MODS.iotMod.value, "RoleAlias")},
        "aws_iot_thing": {"Tok": awsResource(MODS.iotMod.value, "Thing")},
        "aws_iot_thing_principal_attachment": {
            "Tok": awsResource(MODS.iotMod.value, "ThingPrincipalAttachment"),
            "Fields": {
                "principal": {
                    "Type": awsResource(MODS.awsMod.value, "ARN"),
                },
            },
        },
        "aws_iot_thing_type": {"Tok": awsResource(MODS.iotMod.value, "ThingType")},
        "aws_iot_topic_rule": {
            "Tok": awsResource(MODS.iotMod.value, "TopicRule"),
            "Fields": {
                "name": AutoNameWithCustomOptions("name", Separator="_"),
                "cloudwatch_alarm": {"Name": "cloudwatchAlarm", "MaxItemsOne": True},
                "cloudwatch_metric": {"Name": "cloudwatchMetric", "MaxItemsOne": True},
                "dynamodb": {"Name": "dynamodb", "MaxItemsOne": True},
                "elasticsearch": {"Name": "elasticsearch", "MaxItemsOne": True},
                "firehose": {"Name": "firehose", "MaxItemsOne": True},
                "kinesis": {"Name": "kinesis", "MaxItemsOne": True},
                "lambda": {"Name": "lambda", "MaxItemsOne": True},
                "republish": {"Name": "republish", "MaxItemsOne": True},
                "s3": {"Name": "s3", "MaxItemsOne": True},
                "sns": {"Name": "sns", "MaxItemsOne": True},
                "sqs": {"Name": "sqs", "MaxItemsOne": True},
            },
        },
        # Kinesis
        "aws_kinesis_firehose_delivery_stream": {
            "Tok": awsResource(MODS.kinesisMod.value, "FirehoseDeliveryStream")
        },
        "aws_kinesis_stream": {"Tok": awsResource(MODS.kinesisMod.value, "Stream")},
        "aws_kinesis_stream_consumer": {
            "Tok": awsResource(MODS.kinesisMod.value, "StreamConsumer")
        },
        "aws_kinesis_video_stream": {
            "Tok": awsResource(MODS.kinesisMod.value, "VideoStream")
        },
        "aws_kinesis_analytics_application": {
            "Tok": awsResource(MODS.kinesisMod.value, "AnalyticsApplication"),
            "Fields": {
                "arn": {
                    "Type": awsResource(MODS.awsMod.value, "ARN"),
                },
            },
        },
        # Kinesis Data Analytics V2
        "aws_kinesisanalyticsv2_application": {
            "Tok": awsResource(MODS.kinesisAnalyticsMod.value, "Application")
        },
        "aws_kinesisanalyticsv2_application_snapshot": {
            "Tok": awsResource(MODS.kinesisAnalyticsMod.value, "ApplicationSnapshot")
        },
        # Key Management Service (KMS)
        "aws_kms_alias": {
            "Tok": awsResource(MODS.kmsMod.value, "Alias"),
            "Fields": {
                "name": AutoNameWithCustomOptions(
                    "name",
                    Separator="-",
                    Maxlen=238,
                    Randlen=7,
                    # KMS Key alias names must be prefixed with "alias/" - see format documentation at
                    # https:#docs.aws.amazon.com/kms/latest/APIReference/API_CreateAlias.html
                    PostTransform=lambda res, name: name
                    if name.startswith("alias/")
                    else f"alias/{name}",
                ),
            },
        },
        "aws_kms_ciphertext": {"Tok": awsResource(MODS.kmsMod.value, "Ciphertext")},
        "aws_kms_external_key": {"Tok": awsResource(MODS.kmsMod.value, "ExternalKey")},
        "aws_kms_grant": {"Tok": awsResource(MODS.kmsMod.value, "Grant")},
        "aws_kms_key": {"Tok": awsResource(MODS.kmsMod.value, "Key")},
        # Lambda
        "aws_lambda_function": {
            "Tok": awsResource(MODS.lambdaMod.value, "Function"),
            "IDFields": ["function_name"],
            "Fields": {
                "function_name": AutoName("name", 64, "-"),
                "role": {"Type": awsResource(MODS.awsMod.value, "ARN")},
                # Terraform accepts two sources for lambdas: a local filename or a S3 bucket/object.  To bridge
                # with Pulumi's asset model, we will hijack the filename property.  A Pulumi archive is passed in
                # its stead and we will turn around and emit the archive as a temp file that Terraform can read.
                # We also automatically populate the asset hash property as this is used in diffs/updates/etc.
                "filename": {
                    "Name": "code",
                    "Asset": AssetTranslation(
                        Kind=AssetTranslationKind.FileArchive,
                        Format=ArchiveFormat.ZIPArchive,
                        HashField="source_code_hash",
                    ),
                },
                "runtime": {
                    "Type": "string",
                    "AltTypes": [awsType(MODS.lambdaMod.value, "Runtime", "Runtime")],
                },
            },
        },
        "aws_lambda_alias": {"Tok": awsResource(MODS.lambdaMod.value, "Alias")},
        "aws_lambda_event_source_mapping": {
            "Tok": awsResource(MODS.lambdaMod.value, "EventSourceMapping")
        },
        "aws_lambda_layer_version": {
            "Tok": awsResource(MODS.lambdaMod.value, "LayerVersion"),
            "Fields": {
                # We will hijack the filename property. A Pulumi archive is passed in its stead and we will turn
                # around and emit the archive as a temp file that Terraform can read. We also automatically
                # populate the asset hash property as this is used in diffs/updates/etc.
                "filename": {
                    "Name": "code",
                    "Asset": AssetTranslation(
                        Kind=AssetTranslationKind.FileArchive,
                        Format=ArchiveFormat.ZIPArchive,
                        HashField="source_code_hash",
                    ),
                },
            },
        },
        "aws_lambda_permission": {
            "Tok": awsResource(MODS.lambdaMod.value, "Permission"),
            "IDFields": ["statement_id"],
            "Fields": {
                "function_name": {
                    "Name": "function",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.lambdaMod.value, "Function")],
                },
                "statement_id": AutoName("statementId", 100, "-"),
            },
        },
        "aws_lambda_sioned_concurrency_config": {
            "Tok": awsResource(MODS.lambdaMod.value, "sionedConcurrencyConfig")
        },
        "aws_lambda_function_event_invoke_config": {
            "Tok": awsResource(MODS.lambdaMod.value, "FunctionEventInvokeConfig")
        },
        "aws_lambda_code_signing_config": {
            "Tok": awsResource(MODS.lambdaMod.value, "CodeSigningConfig")
        },
        # License Manager
        "aws_licensemanager_association": {
            "Tok": awsResource(MODS.licensemanagerMod.value, "Association")
        },
        "aws_licensemanager_license_configuration": {
            "Tok": awsResource(MODS.licensemanagerMod.value, "LicenseConfiguration")
        },
        # LightSail
        "aws_lightsail_domain": {"Tok": awsResource(MODS.lightsailMod.value, "Domain")},
        "aws_lightsail_instance": {
            "Tok": awsResource(MODS.lightsailMod.value, "Instance")
        },
        "aws_lightsail_key_pair": {
            "Tok": awsResource(MODS.lightsailMod.value, "KeyPair")
        },
        "aws_lightsail_static_ip": {
            "Tok": awsResource(MODS.lightsailMod.value, "StaticIp")
        },
        "aws_lightsail_static_ip_attachment": {
            "Tok": awsResource(MODS.lightsailMod.value, "StaticIpAttachment")
        },
        "aws_lightsail_instance_public_ports": {
            "Tok": awsResource(MODS.lightsailMod.value, "InstancePublicPorts")
        },
        # Macie
        "aws_macie_member_account_association": {
            "Tok": awsResource(MODS.macieMod.value, "MemberAccountAssociation")
        },
        "aws_macie_s3_bucket_association": {
            "Tok": awsResource(MODS.macieMod.value, "S3BucketAssociation")
        },
        "aws_macie2_custom_data_identifier": {
            "Tok": awsResource(MODS.macieMod.value, "CustomDataIdentifier")
        },
        "aws_macie2_findings_filter": {
            "Tok": awsResource(MODS.macieMod.value, "FindingsFilter")
        },
        # Macie2
        "aws_macie2_account": {"Tok": awsResource(MODS.macie2Mod.value, "Account")},
        "aws_macie2_classification_job": {
            "Tok": awsResource(MODS.macie2Mod.value, "ClassificationJob")
        },
        "aws_macie2_invitation_accepter": {
            "Tok": awsResource(MODS.macie2Mod.value, "InvitationAccepter")
        },
        "aws_macie2_member": {"Tok": awsResource(MODS.macie2Mod.value, "Member")},
        "aws_macie2_organization_admin_account": {
            "Tok": awsResource(MODS.macie2Mod.value, "OrganizationAdminAccount")
        },
        # Elemental MediaPackage
        "aws_media_package_channel": {
            "Tok": awsResource(MODS.mediapackageMod.value, "Channel"),
            "Fields": {
                "description": {
                    "Default": managedByPulumi,
                },
            },
        },
        # MediaConvert
        "aws_media_convert_queue": {
            "Tok": awsResource(MODS.mediaconvertMod.value, "Queue")
        },
        # Elemental MediaStore
        "aws_media_store_container": {
            "Tok": awsResource(MODS.mediastoreMod.value, "Container")
        },
        "aws_media_store_container_policy": {
            "Tok": awsResource(MODS.mediastoreMod.value, "ContainerPolicy")
        },
        # MQ
        "aws_mq_broker": {
            "Tok": awsResource(MODS.mqMod.value, "Broker"),
            "Fields": {
                "logs": {
                    "Elem": {
                        "Fields": {
                            "audit": {
                                "Type": "boolean",
                            },
                        },
                    },
                },
            },
        },
        "aws_mq_configuration": {"Tok": awsResource(MODS.mqMod.value, "Configuration")},
        # Neptune
        "aws_neptune_cluster": {"Tok": awsResource(MODS.neptuneMod.value, "Cluster")},
        "aws_neptune_cluster_instance": {
            "Tok": awsResource(MODS.neptuneMod.value, "ClusterInstance")
        },
        "aws_neptune_cluster_parameter_group": {
            "Tok": awsResource(MODS.neptuneMod.value, "ClusterParameterGroup")
        },
        "aws_neptune_cluster_snapshot": {
            "Tok": awsResource(MODS.neptuneMod.value, "ClusterSnapshot")
        },
        "aws_neptune_event_subscription": {
            "Tok": awsResource(MODS.neptuneMod.value, "EventSubscription")
        },
        "aws_neptune_parameter_group": {
            "Tok": awsResource(MODS.neptuneMod.value, "ParameterGroup")
        },
        "aws_neptune_cluster_endpoint": {
            "Tok": awsResource(MODS.neptuneMod.value, "ClusterEndpoint")
        },
        "aws_neptune_subnet_group": {
            "Tok": awsResource(MODS.neptuneMod.value, "SubnetGroup"),
            "Fields": {
                "description": {
                    "Default": managedByPulumi,
                },
            },
        },
        # OpsWorks
        "aws_opsworks_application": {
            "Tok": awsResource(MODS.opsworksMod.value, "Application")
        },
        "aws_opsworks_stack": {"Tok": awsResource(MODS.opsworksMod.value, "Stack")},
        "aws_opsworks_java_app_layer": {
            "Tok": awsResource(MODS.opsworksMod.value, "JavaAppLayer")
        },
        "aws_opsworks_haproxy_layer": {
            "Tok": awsResource(MODS.opsworksMod.value, "HaproxyLayer")
        },
        "aws_opsworks_static_web_layer": {
            "Tok": awsResource(MODS.opsworksMod.value, "StaticWebLayer")
        },
        "aws_opsworks_php_app_layer": {
            "Tok": awsResource(MODS.opsworksMod.value, "PhpAppLayer")
        },
        "aws_opsworks_rails_app_layer": {
            "Tok": awsResource(MODS.opsworksMod.value, "RailsAppLayer")
        },
        "aws_opsworks_nodejs_app_layer": {
            "Tok": awsResource(MODS.opsworksMod.value, "NodejsAppLayer")
        },
        "aws_opsworks_memcached_layer": {
            "Tok": awsResource(MODS.opsworksMod.value, "MemcachedLayer")
        },
        "aws_opsworks_mysql_layer": {
            "Tok": awsResource(MODS.opsworksMod.value, "MysqlLayer")
        },
        "aws_opsworks_ganglia_layer": {
            "Tok": awsResource(MODS.opsworksMod.value, "GangliaLayer")
        },
        "aws_opsworks_custom_layer": {
            "Tok": awsResource(MODS.opsworksMod.value, "CustomLayer")
        },
        "aws_opsworks_instance": {
            "Tok": awsResource(MODS.opsworksMod.value, "Instance")
        },
        "aws_opsworks_user_profile": {
            "Tok": awsResource(MODS.opsworksMod.value, "UserProfile")
        },
        "aws_opsworks_permission": {
            "Tok": awsResource(MODS.opsworksMod.value, "Permission")
        },
        "aws_opsworks_rds_db_instance": {
            "Tok": awsResource(MODS.opsworksMod.value, "RdsDbInstance")
        },
        # Organizations
        "aws_organizations_account": {
            "Tok": awsResource(MODS.organizationsMod.value, "Account")
        },
        "aws_organizations_organization": {
            "Tok": awsResource(MODS.organizationsMod.value, "Organization")
        },
        "aws_organizations_organizational_unit": {
            "Tok": awsResource(MODS.organizationsMod.value, "OrganizationalUnit")
        },
        "aws_organizations_policy": {
            "Tok": awsResource(MODS.organizationsMod.value, "Policy")
        },
        "aws_organizations_policy_attachment": {
            "Tok": awsResource(MODS.organizationsMod.value, "PolicyAttachment")
        },
        "aws_organizations_delegated_administrator": {
            "Tok": awsResource(MODS.organizationsMod.value, "DelegatedAdministrator")
        },
        # Pinpoint
        "aws_pinpoint_adm_channel": {
            "Tok": awsResource(MODS.pinpointMod.value, "AdmChannel")
        },
        "aws_pinpoint_apns_channel": {
            "Tok": awsResource(MODS.pinpointMod.value, "ApnsChannel")
        },
        "aws_pinpoint_apns_sandbox_channel": {
            "Tok": awsResource(MODS.pinpointMod.value, "ApnsSandboxChannel")
        },
        "aws_pinpoint_apns_voip_channel": {
            "Tok": awsResource(MODS.pinpointMod.value, "ApnsVoipChannel")
        },
        "aws_pinpoint_apns_voip_sandbox_channel": {
            "Tok": awsResource(MODS.pinpointMod.value, "ApnsVoipSandboxChannel")
        },
        "aws_pinpoint_app": {"Tok": awsResource(MODS.pinpointMod.value, "App")},
        "aws_pinpoint_baidu_channel": {
            "Tok": awsResource(MODS.pinpointMod.value, "BaiduChannel")
        },
        "aws_pinpoint_email_channel": {
            "Tok": awsResource(MODS.pinpointMod.value, "EmailChannel")
        },
        "aws_pinpoint_event_stream": {
            "Tok": awsResource(MODS.pinpointMod.value, "EventStream")
        },
        "aws_pinpoint_gcm_channel": {
            "Tok": awsResource(MODS.pinpointMod.value, "GcmChannel")
        },
        "aws_pinpoint_sms_channel": {
            "Tok": awsResource(MODS.pinpointMod.value, "SmsChannel")
        },
        # Resource Access Manager
        "aws_ram_resource_share": {
            "Tok": awsResource(MODS.ramMod.value, "ResourceShare")
        },
        "aws_ram_resource_share_accepter": {
            "Tok": awsResource(MODS.ramMod.value, "ResourceShareAccepter")
        },
        "aws_ram_principal_association": {
            "Tok": awsResource(MODS.ramMod.value, "PrincipalAssociation")
        },
        "aws_ram_resource_association": {
            "Tok": awsResource(MODS.ramMod.value, "ResourceAssociation")
        },
        # Relational Database Service (RDS)
        "aws_rds_cluster": {
            "Tok": awsResource(MODS.rdsMod.value, "Cluster"),
            "Fields": {
                "engine": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.rdsMod.value, "EngineType", "EngineType")
                    ],
                },
                "engine_mode": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.rdsMod.value, "EngineMode", "EngineMode")
                    ],
                },
            },
        },
        "aws_rds_cluster_endpoint": {
            "Tok": awsResource(MODS.rdsMod.value, "ClusterEndpoint")
        },
        "aws_rds_cluster_instance": {
            "Tok": awsResource(MODS.rdsMod.value, "ClusterInstance"),
            "Fields": {
                "engine": {
                    "Type": awsResource(MODS.rdsMod.value, "EngineType"),
                },
                "instance_class": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.rdsMod.value, "InstanceType", "InstanceType")
                    ],
                },
            },
        },
        "aws_rds_cluster_parameter_group": {
            "Tok": awsResource(MODS.rdsMod.value, "ClusterParameterGroup"),
            "Fields": {
                "description": {
                    "Default": managedByPulumi,
                },
            },
        },
        "aws_rds_global_cluster": {
            "Tok": awsResource(MODS.rdsMod.value, "GlobalCluster")
        },
        "aws_rds_cluster_role_association": {
            "Tok": awsResource(MODS.rdsMod.value, "ClusterRoleAssociation")
        },
        "aws_db_cluster_snapshot": {
            "Tok": awsResource(MODS.rdsMod.value, "ClusterSnapshot")
        },
        "aws_db_event_subscription": {
            "Tok": awsResource(MODS.rdsMod.value, "EventSubscription")
        },
        "aws_db_instance": {
            "Tok": awsResource(MODS.rdsMod.value, "Instance"),
            "Fields": {
                "identifier": {
                    "Default": {
                        # TODO: translate this
                        # "From": func(res *PulumiResource) (interface{}, error) {
                        #     name, rand, maxlen := string(res.URN.Name()), 7, 255
                        #     if engine, ok := res.Properties["engine"]; ok && engine.IsString() {
                        #         if strings.Contains(strings.ToLower(engine.StringValue()), "sqlserver") {
                        #             # SQL Server identifiers are capped at 15 characters.
                        #             rand, maxlen = 3, 15
                        #         }
                        #     }
                        #     return resource.NewUniqueHex(name, rand, maxlen)
                        # },
                    },
                },
                "name": {"Name": "name"},
                "instance_class": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.rdsMod.value, "InstanceType", "InstanceType")
                    ],
                },
                "storage_type": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.rdsMod.value, "StorageType", "StorageType")
                    ],
                },
            },
        },
        "aws_db_option_group": {
            "Tok": awsResource(MODS.rdsMod.value, "OptionGroup"),
            "Fields": {
                "option_group_description": {
                    "Default": managedByPulumi,
                },
            },
        },
        "aws_db_parameter_group": {
            "Tok": awsResource(MODS.rdsMod.value, "ParameterGroup"),
            "Fields": {
                "description": {
                    "Default": managedByPulumi,
                },
            },
        },
        "aws_db_instance_role_association": {
            "Tok": awsResource(MODS.rdsMod.value, "RoleAssociation"),
        },
        "aws_db_security_group": {
            "Tok": awsResource(MODS.rdsMod.value, "SecurityGroup"),
            "Fields": {
                "description": {"Default": managedByPulumi},
                # Use "ingress" instead of "ingresses" to match AWS APIs
                "ingress": {"Name": "ingress"},
            },
        },
        "aws_db_snapshot": {"Tok": awsResource(MODS.rdsMod.value, "Snapshot")},
        "aws_db_subnet_group": {
            "Tok": awsResource(MODS.rdsMod.value, "SubnetGroup"),
            "Fields": {
                "description": {
                    "Default": managedByPulumi,
                },
            },
        },
        "aws_db_proxy": {"Tok": awsResource(MODS.rdsMod.value, "Proxy")},
        "aws_db_proxy_default_target_group": {
            "Tok": awsResource(MODS.rdsMod.value, "ProxyDefaultTargetGroup")
        },
        "aws_db_proxy_target": {"Tok": awsResource(MODS.rdsMod.value, "ProxyTarget")},
        "aws_db_proxy_endpoint": {
            "Tok": awsResource(MODS.rdsMod.value, "ProxyEndpoint")
        },
        # RedShift
        "aws_redshift_cluster": {"Tok": awsResource(MODS.redshiftMod.value, "Cluster")},
        "aws_redshift_event_subscription": {
            "Tok": awsResource(MODS.redshiftMod.value, "EventSubscription")
        },
        "aws_redshift_parameter_group": {
            "Tok": awsResource(MODS.redshiftMod.value, "ParameterGroup"),
            "Fields": {
                "description": {
                    "Default": managedByPulumi,
                },
            },
        },
        "aws_redshift_security_group": {
            "Tok": awsResource(MODS.redshiftMod.value, "SecurityGroup"),
            "Fields": {
                "description": {"Default": managedByPulumi},
                # Use "ingress" instead of "ingresses" to match AWS APIs
                "ingress": {"Name": "ingress"},
            },
        },
        "aws_redshift_snapshot_copy_grant": {
            "Tok": awsResource(MODS.redshiftMod.value, "SnapshotCopyGrant")
        },
        "aws_redshift_subnet_group": {
            "Tok": awsResource(MODS.redshiftMod.value, "SubnetGroup"),
            "Fields": {
                "description": {
                    "Default": managedByPulumi,
                },
            },
        },
        "aws_redshift_snapshot_schedule": {
            "Tok": awsResource(MODS.redshiftMod.value, "SnapshotSchedule")
        },
        "aws_redshift_snapshot_schedule_association": {
            "Tok": awsResource(MODS.redshiftMod.value, "SnapshotScheduleAssociation")
        },
        # Resource Groups
        "aws_resourcegroups_group": {
            "Tok": awsResource(MODS.resourcegroupsMod.value, "Group")
        },
        # Route53
        "aws_route53_delegation_set": {
            "Tok": awsResource(MODS.route53Mod.value, "DelegationSet")
        },
        "aws_route53_record": {
            "Tok": awsResource(MODS.route53Mod.value, "Record"),
            "Fields": {
                "type": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.route53Mod.value, "RecordType", "RecordType")
                    ],
                },
                # Do not autoname Route53 records, as the "name" of these is actually the true
                # domain name of the DNS record.
                "name": {"Name": "name"},
            },
        },
        "aws_route53_resolver_endpoint": {
            "Tok": awsResource(MODS.route53Mod.value, "ResolverEndpoint")
        },
        "aws_route53_resolver_rule": {
            "Tok": awsResource(MODS.route53Mod.value, "ResolverRule")
        },
        "aws_route53_resolver_rule_association": {
            "Tok": awsResource(MODS.route53Mod.value, "ResolverRuleAssociation")
        },
        "aws_route53_query_log": {
            "Tok": awsResource(MODS.route53Mod.value, "QueryLog")
        },
        "aws_route53_zone_association": {
            "Tok": awsResource(MODS.route53Mod.value, "ZoneAssociation")
        },
        "aws_route53_vpc_association_authorization": {
            "Tok": awsResource(MODS.route53Mod.value, "VpcAssociationAuthorization")
        },
        "aws_route53_zone": {
            "Tok": awsResource(MODS.route53Mod.value, "Zone"),
            "Fields": {
                "comment": {
                    "Default": managedByPulumi,
                },
            },
        },
        "aws_route53_health_check": {
            "Tok": awsResource(MODS.route53Mod.value, "HealthCheck")
        },
        "aws_route53_hosted_zone_dnssec": {
            "Tok": awsResource(MODS.route53Mod.value, "HostedZoneDnsSec")
        },
        "aws_route53_key_signing_key": {
            "Tok": awsResource(MODS.route53Mod.value, "KeySigningKey")
        },
        "aws_route53_resolver_dnssec_config": {
            "Tok": awsResource(MODS.route53Mod.value, "ResolverDnsSecConfig")
        },
        "aws_route53_resolver_query_log_config": {
            "Tok": awsResource(MODS.route53Mod.value, "ResolverQueryLogConfig")
        },
        "aws_route53_resolver_query_log_config_association": {
            "Tok": awsResource(
                MODS.route53Mod.value, "ResolverQueryLogConfigAssociation"
            ),
        },
        "aws_route53_resolver_firewall_rule_group": {
            "Tok": awsResource(MODS.route53Mod.value, "ResolverFirewallRuleGroup"),
        },
        "aws_route53_resolver_firewall_domain_list": {
            "Tok": awsResource(MODS.route53Mod.value, "ResolverFirewallDomainList")
        },
        "aws_route53_resolver_firewall_rule": {
            "Tok": awsResource(MODS.route53Mod.value, "ResolverFirewallRule")
        },
        "aws_route53_resolver_firewall_rule_group_association": {
            "Tok": awsResource(
                MODS.route53Mod.value, "ResolverFirewallRuleGroupAssociation"
            ),
        },
        "aws_route53_resolver_firewall_config": {
            "Tok": awsResource(MODS.route53Mod.value, "ResolverFirewallConfig")
        },
        # Rout53 Recovery Control
        "aws_route53recoverycontrolconfig_cluster": {
            "Tok": awsResource(MODS.route53RecoveryControlMod.value, "Cluster")
        },
        "aws_route53recoverycontrolconfig_control_panel": {
            "Tok": awsResource(MODS.route53RecoveryControlMod.value, "ControlPanel")
        },
        "aws_route53recoverycontrolconfig_routing_control": {
            "Tok": awsResource(MODS.route53RecoveryControlMod.value, "RoutingControl")
        },
        "aws_route53recoverycontrolconfig_safety_rule": {
            "Tok": awsResource(MODS.route53RecoveryControlMod.value, "SafetyRule")
        },
        # Route53 Recovery Readiness
        "aws_route53recoveryreadiness_cell": {
            "Tok": awsResource(MODS.route53RecoveryReadinessMod.value, "Cell")
        },
        "aws_route53recoveryreadiness_readiness_check": {
            "Tok": awsResource(MODS.route53RecoveryReadinessMod.value, "ReadinessCheck")
        },
        "aws_route53recoveryreadiness_recovery_group": {
            "Tok": awsResource(MODS.route53RecoveryReadinessMod.value, "RecoveryGroup")
        },
        "aws_route53recoveryreadiness_resource_set": {
            "Tok": awsResource(MODS.route53RecoveryReadinessMod.value, "ResourceSet")
        },
        # Sagemaker
        "aws_sagemaker_endpoint": {
            "Tok": awsResource(MODS.sagemakerMod.value, "Endpoint")
        },
        "aws_sagemaker_endpoint_configuration": {
            "Tok": awsResource(MODS.sagemakerMod.value, "EndpointConfiguration")
        },
        "aws_sagemaker_model": {"Tok": awsResource(MODS.sagemakerMod.value, "Model")},
        "aws_sagemaker_notebook_instance": {
            "Tok": awsResource(MODS.sagemakerMod.value, "NotebookInstance")
        },
        "aws_sagemaker_code_repository": {
            "Tok": awsResource(MODS.sagemakerMod.value, "CodeRepository")
        },
        "aws_sagemaker_image": {"Tok": awsResource(MODS.sagemakerMod.value, "Image")},
        "aws_sagemaker_domain": {"Tok": awsResource(MODS.sagemakerMod.value, "Domain")},
        "aws_sagemaker_feature_group": {
            "Tok": awsResource(MODS.sagemakerMod.value, "FeatureGroup")
        },
        "aws_sagemaker_image_version": {
            "Tok": awsResource(MODS.sagemakerMod.value, "ImageVersion")
        },
        "aws_sagemaker_user_profile": {
            "Tok": awsResource(MODS.sagemakerMod.value, "UserProfile")
        },
        "aws_sagemaker_app_image_config": {
            "Tok": awsResource(MODS.sagemakerMod.value, "AppImageConfig")
        },
        "aws_sagemaker_model_package_group": {
            "Tok": awsResource(MODS.sagemakerMod.value, "ModelPackageGroup")
        },
        "aws_sagemaker_app": {"Tok": awsResource(MODS.sagemakerMod.value, "App")},
        "aws_sagemaker_workforce": {
            "Tok": awsResource(MODS.sagemakerMod.value, "Workforce")
        },
        "aws_sagemaker_workteam": {
            "Tok": awsResource(MODS.sagemakerMod.value, "Workteam")
        },
        "aws_sagemaker_notebook_instance_lifecycle_configuration": {
            "Tok": awsResource(
                MODS.sagemakerMod.value, "NotebookInstanceLifecycleConfiguration"
            ),
        },
        "aws_sagemaker_device_fleet": {
            "Tok": awsResource(MODS.sagemakerMod.value, "DeviceFleet")
        },
        "aws_sagemaker_human_task_ui": {
            "Tok": awsResource(MODS.sagemakerMod.value, "HumanTaskUI")
        },
        "aws_sagemaker_flow_definition": {
            "Tok": awsResource(MODS.sagemakerMod.value, "FlowDefinition")
        },
        # Schemas
        "aws_schemas_discoverer": {
            "Tok": awsResource(MODS.schemasMod.value, "Discoverer")
        },
        "aws_schemas_registry": {"Tok": awsResource(MODS.schemasMod.value, "Registry")},
        "aws_schemas_schema": {"Tok": awsResource(MODS.schemasMod.value, "Schema")},
        # Secrets Manager
        "aws_secretsmanager_secret": {
            "Tok": awsResource(MODS.secretsmanagerMod.value, "Secret")
        },
        "aws_secretsmanager_secret_version": {
            "Tok": awsResource(MODS.secretsmanagerMod.value, "SecretVersion")
        },
        "aws_secretsmanager_secret_rotation": {
            "Tok": awsResource(MODS.secretsmanagerMod.value, "SecretRotation")
        },
        "aws_secretsmanager_secret_policy": {
            "Tok": awsResource(MODS.secretsmanagerMod.value, "SecretPolicy")
        },
        # Service Catalog
        "aws_servicecatalog_portfolio": {
            "Tok": awsResource(MODS.servicecatalogMod.value, "Portfolio")
        },
        "aws_servicecatalog_product": {
            "Tok": awsResource(MODS.servicecatalogMod.value, "Product")
        },
        "aws_servicecatalog_tag_option": {
            "Tok": awsResource(MODS.servicecatalogMod.value, "TagOption")
        },
        "aws_servicecatalog_organizations_access": {
            "Tok": awsResource(MODS.servicecatalogMod.value, "OrganizationsAccess")
        },
        "aws_servicecatalog_portfolio_share": {
            "Tok": awsResource(MODS.servicecatalogMod.value, "PortfolioShare")
        },
        "aws_servicecatalog_constraint": {
            "Tok": awsResource(MODS.servicecatalogMod.value, "Constraint")
        },
        "aws_servicecatalog_product_portfolio_association": {
            "Tok": awsResource(
                MODS.servicecatalogMod.value, "ProductPortfolioAssociation"
            ),
        },
        "aws_servicecatalog_service_action": {
            "Tok": awsResource(MODS.servicecatalogMod.value, "ServiceAction")
        },
        "aws_servicecatalog_budget_resource_association": {
            "Tok": awsResource(
                MODS.servicecatalogMod.value, "BudgetResourceAssociation"
            ),
        },
        "aws_servicecatalog_sioning_artifact": {
            "Tok": awsResource(MODS.servicecatalogMod.value, "sioningArtifact")
        },
        "aws_servicecatalog_tag_option_resource_association": {
            "Tok": awsResource(
                MODS.servicecatalogMod.value, "TagOptionResourceAssociation"
            ),
        },
        "aws_servicecatalog_principal_portfolio_association": {
            "Tok": awsResource(
                MODS.servicecatalogMod.value, "PrincipalPortfolioAssociation"
            ),
        },
        "aws_servicecatalog_sioned_product": {
            "Tok": awsResource(MODS.servicecatalogMod.value, "sionedProduct")
        },
        # Security Hub
        "aws_securityhub_account": {
            "Tok": awsResource(MODS.securityhubMod.value, "Account")
        },
        "aws_securityhub_product_subscription": {
            "Tok": awsResource(MODS.securityhubMod.value, "ProductSubscription")
        },
        "aws_securityhub_standards_subscription": {
            "Tok": awsResource(MODS.securityhubMod.value, "StandardsSubscription")
        },
        "aws_securityhub_member": {
            "Tok": awsResource(MODS.securityhubMod.value, "Member")
        },
        "aws_securityhub_action_target": {
            "Tok": awsResource(MODS.securityhubMod.value, "ActionTarget")
        },
        "aws_securityhub_organization_admin_account": {
            "Tok": awsResource(MODS.securityhubMod.value, "OrganizationAdminAccount")
        },
        "aws_securityhub_invite_accepter": {
            "Tok": awsResource(MODS.securityhubMod.value, "InviteAccepter")
        },
        "aws_securityhub_insight": {
            "Tok": awsResource(MODS.securityhubMod.value, "Insight")
        },
        "aws_securityhub_organization_configuration": {
            "Tok": awsResource(MODS.securityhubMod.value, "OrganizationConfiguration")
        },
        "aws_securityhub_standards_control": {
            "Tok": awsResource(MODS.securityhubMod.value, "StandardsControl")
        },
        # Service Discovery
        "aws_service_discovery_http_namespace": {
            "Tok": awsResource(MODS.servicediscoveryMod.value, "HttpNamespace")
        },
        "aws_service_discovery_private_dns_namespace": {
            "Tok": awsResource(MODS.servicediscoveryMod.value, "PrivateDnsNamespace")
        },
        "aws_service_discovery_public_dns_namespace": {
            "Tok": awsResource(MODS.servicediscoveryMod.value, "PublicDnsNamespace")
        },
        "aws_service_discovery_service": {
            "Tok": awsResource(MODS.servicediscoveryMod.value, "Service")
        },
        "aws_service_discovery_instance": {
            "Tok": awsResource(MODS.servicediscoveryMod.value, "Instance")
        },
        # Simple Email Service (SES)
        "aws_ses_active_receipt_rule_set": {
            "Tok": awsResource(MODS.sesMod.value, "ActiveReceiptRuleSet")
        },
        "aws_ses_domain_dkim": {"Tok": awsResource(MODS.sesMod.value, "DomainDkim")},
        "aws_ses_domain_identity": {
            "Tok": awsResource(MODS.sesMod.value, "DomainIdentity")
        },
        "aws_ses_domain_identity_verification": {
            "Tok": awsResource(MODS.sesMod.value, "DomainIdentityVerification")
        },
        "aws_ses_domain_mail_from": {"Tok": awsResource(MODS.sesMod.value, "MailFrom")},
        "aws_ses_email_identity": {
            "Tok": awsResource(MODS.sesMod.value, "EmailIdentity")
        },
        "aws_ses_identity_notification_topic": {
            "Tok": awsResource(MODS.sesMod.value, "IdentityNotificationTopic")
        },
        "aws_ses_identity_policy": {
            "Tok": awsResource(MODS.sesMod.value, "IdentityPolicy")
        },
        "aws_ses_receipt_filter": {
            "Tok": awsResource(MODS.sesMod.value, "ReceiptFilter")
        },
        "aws_ses_receipt_rule": {"Tok": awsResource(MODS.sesMod.value, "ReceiptRule")},
        "aws_ses_receipt_rule_set": {
            "Tok": awsResource(MODS.sesMod.value, "ReceiptRuleSet")
        },
        "aws_ses_event_destination": {
            "Tok": awsResource(MODS.sesMod.value, "EventDestination")
        },
        "aws_ses_template": {"Tok": awsResource(MODS.sesMod.value, "Template")},
        # Shield
        "aws_shield_protection": {
            "Tok": awsResource(MODS.shieldMod.value, "Protection")
        },
        "aws_shield_protection_group": {
            "Tok": awsResource(MODS.shieldMod.value, "ProtectionGroup")
        },
        # S3
        "aws_s3_account_public_access_block": {
            "Tok": awsResource(MODS.s3Mod.value, "AccountPublicAccessBlock")
        },
        "aws_s3_bucket": {
            "Tok": awsResource(MODS.s3Mod.value, "Bucket"),
            "Fields": {
                "acl": {
                    "Type": "string",
                    "AltTypes": [awsType(MODS.s3Mod.value, "CannedAcl", "CannedAcl")],
                },
                "bucket": AutoNameTransform("bucket", 63, lambda name: name.lower()),
                # Website only accepts a single value in the AWS API but is not marked MaxItems==1 in the TF
                # der.
                "website": {
                    "Name": "website",
                    "Elem": {
                        "Fields": {
                            "routing_rules": {
                                "Name": "routingRules",
                                "Type": "string",
                                "AltTypes": [
                                    awsType(
                                        MODS.s3Mod.value,
                                        "routingRules",
                                        "RoutingRule[]",
                                    )
                                ],
                                "Transform": TransformJSONDocument,
                            },
                        },
                    },
                },
                "policy": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                    ],
                    "Transform": TransformJSONDocument,
                },
            },
        },
        "aws_s3_bucket_inventory": {"Tok": awsResource(MODS.s3Mod.value, "Inventory")},
        "aws_s3_bucket_metric": {"Tok": awsResource(MODS.s3Mod.value, "BucketMetric")},
        "aws_s3_bucket_notification": {
            "Tok": awsResource(MODS.s3Mod.value, "BucketNotification")
        },
        "aws_s3_bucket_object": {
            "Tok": awsResource(MODS.s3Mod.value, "BucketObject"),
            "IDFields": ["bucket", "key"],
            "Fields": {
                "bucket": {
                    # Prefer a strongly typed Bucket reference.
                    "Type": "string",
                    # But also permit a string in cases where all we have is a name.
                    "AltTypes": [awsResource(MODS.s3Mod.value, "Bucket")],
                },
                "key": {
                    # By default, use the name as the key.  It may of course be overridden.
                    "Default": {
                        "From": FromName(
                            Maxlen=0,
                            Randlen=0,
                            Transform=None,
                        ),
                    },
                },
                "source": {
                    "Asset": AssetTranslation(Kind=AssetTranslationKind.FileAsset),
                },
            },
        },
        "aws_s3_bucket_policy": {
            "Tok": awsResource(MODS.s3Mod.value, "BucketPolicy"),
            "Fields": {
                "policy": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                    ],
                    "Transform": TransformJSONDocument,
                },
            },
        },
        "aws_s3_bucket_public_access_block": {
            "Tok": awsResource(MODS.s3Mod.value, "BucketPublicAccessBlock")
        },
        "aws_s3_bucket_analytics_configuration": {
            "Tok": awsResource(MODS.s3Mod.value, "AnalyticsConfiguration"),
            "Docs": {
                "Source": "s3_bucket_analysis_configuration.html.markdown",
            },
        },
        "aws_s3_access_point": {"Tok": awsResource(MODS.s3Mod.value, "AccessPoint")},
        "aws_s3_bucket_ownership_controls": {
            "Tok": awsResource(MODS.s3Mod.value, "BucketOwnershipControls")
        },
        "aws_s3_object_copy": {"Tok": awsResource(MODS.s3Mod.value, "ObjectCopy")},
        # S3 Control
        "aws_s3control_bucket": {
            "Tok": awsResource(MODS.s3ControlMod.value, "Bucket"),
            "Fields": {
                "bucket": {
                    "CsharpName": "BucketName",
                },
            },
        },
        "aws_s3control_bucket_lifecycle_configuration": {
            "Tok": awsResource(MODS.s3ControlMod.value, "BucketLifecycleConfiguration")
        },
        "aws_s3control_bucket_policy": {
            "Tok": awsResource(MODS.s3ControlMod.value, "BucketPolicy")
        },
        # S3 Outposts
        "aws_s3outposts_endpoint": {
            "Tok": awsResource(MODS.s3OutpostsMod.value, "Endpoint")
        },
        # Systems Manager (SSM)
        "aws_ssm_activation": {"Tok": awsResource(MODS.ssmMod.value, "Activation")},
        "aws_ssm_association": {"Tok": awsResource(MODS.ssmMod.value, "Association")},
        "aws_ssm_document": {"Tok": awsResource(MODS.ssmMod.value, "Document")},
        "aws_ssm_maintenance_window": {
            "Tok": awsResource(MODS.ssmMod.value, "MaintenanceWindow")
        },
        "aws_ssm_maintenance_window_target": {
            "Tok": awsResource(MODS.ssmMod.value, "MaintenanceWindowTarget")
        },
        "aws_ssm_maintenance_window_task": {
            "Tok": awsResource(MODS.ssmMod.value, "MaintenanceWindowTask")
        },
        "aws_ssm_patch_baseline": {
            "Tok": awsResource(MODS.ssmMod.value, "PatchBaseline")
        },
        "aws_ssm_patch_group": {
            "Tok": awsResource(MODS.ssmMod.value, "PatchGroup"),
            "Fields": {
                "patch_group": {
                    "CsharpName": "PatchGroupName",
                },
            },
        },
        "aws_ssm_parameter": {
            "Tok": awsResource(MODS.ssmMod.value, "Parameter"),
            "Fields": {
                "type": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.ssmMod.value, "ParameterType", "ParameterType")
                    ],
                },
            },
        },
        "aws_ssm_resource_data_sync": {
            "Tok": awsResource(MODS.ssmMod.value, "ResourceDataSync")
        },
        # SimpleDB
        "aws_simpledb_domain": {"Tok": awsResource(MODS.simpledbMod.value, "Domain")},
        # Simple Queuing Service (SQS)
        "aws_sqs_queue": {
            "Tok": awsResource(MODS.sqsMod.value, "Queue"),
            "Fields": {
                "name": AutoNameWithCustomOptions(
                    "name",
                    Separator="-",
                    Maxlen=80,
                    Randlen=7,
                    # If this is a FIFO Queue, it's name must end with `.fifo`
                    PostTransform=lambda res, name: f"{name}.fifo"
                    if res.Properties.get("fifoQueue")
                    else name,
                ),
            },
        },
        "aws_sqs_queue_policy": {
            "Tok": awsResource(MODS.sqsMod.value, "QueuePolicy"),
            "Fields": {
                "policy": {
                    "Type": "string",
                    "AltTypes": [
                        awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                    ],
                    "Transform": TransformJSONDocument,
                },
            },
        },
        # Storage Gateway
        "aws_storagegateway_gateway": {
            "Tok": awsResource(MODS.storagegatewayMod.value, "Gateway")
        },
        "aws_storagegateway_cache": {
            "Tok": awsResource(MODS.storagegatewayMod.value, "Cache")
        },
        "aws_storagegateway_cached_iscsi_volume": {
            "Tok": awsResource(MODS.storagegatewayMod.value, "CachesIscsiVolume")
        },
        "aws_storagegateway_nfs_file_share": {
            "Tok": awsResource(MODS.storagegatewayMod.value, "NfsFileShare")
        },
        "aws_storagegateway_smb_file_share": {
            "Tok": awsResource(MODS.storagegatewayMod.value, "SmbFileShare")
        },
        "aws_storagegateway_upload_buffer": {
            "Tok": awsResource(MODS.storagegatewayMod.value, "UploadBuffer")
        },
        "aws_storagegateway_working_storage": {
            "Tok": awsResource(MODS.storagegatewayMod.value, "WorkingStorage")
        },
        "aws_storagegateway_stored_iscsi_volume": {
            "Tok": awsResource(MODS.storagegatewayMod.value, "StoredIscsiVolume")
        },
        "aws_storagegateway_tape_pool": {
            "Tok": awsResource(MODS.storagegatewayMod.value, "TapePool")
        },
        "aws_storagegateway_file_system_association": {
            "Tok": awsResource(MODS.storagegatewayMod.value, "FileSystemAssociation"),
        },
        # Simple Notification Service (SNS)
        "aws_sns_platform_application": {
            "Tok": awsResource(MODS.snsMod.value, "PlatformApplication")
        },
        "aws_sns_sms_preferences": {
            "Tok": awsResource(MODS.snsMod.value, "SmsPreferences")
        },
        "aws_sns_topic": {
            "Tok": awsResource(MODS.snsMod.value, "Topic"),
            "Fields": {
                "arn": {"Type": awsResource(MODS.awsMod.value, "ARN")},
                "name": AutoNameWithCustomOptions(
                    "name",
                    Separator="-",
                    Maxlen=80,
                    Randlen=7,
                    # If this is a FIFO topic, it's name must end with `.fifo`
                    PostTransform=lambda res, name: f"{name}.fifo"
                    if res.Properties.get("fifoTopic")
                    else name,
                ),
            },
        },
        "aws_sns_topic_policy": {
            "Tok": awsResource(MODS.snsMod.value, "TopicPolicy"),
            "Fields": {
                "policy": {
                    "Elem": {
                        "Type": "string",
                        "AltTypes": [
                            awsType(MODS.iamMod.value, "documents", "PolicyDocument")
                        ],
                        "Transform": TransformJSONDocument,
                    },
                },
            },
        },
        "aws_sns_topic_subscription": {
            "Tok": awsResource(MODS.snsMod.value, "TopicSubscription"),
            "Fields": {
                "topic_arn": {
                    "Name": "topic",
                    "Type": "string",
                    "AltTypes": [awsResource(MODS.snsMod.value, "Topic")],
                },
            },
        },
        # Step Functions (SFN)
        "aws_sfn_activity": {"Tok": awsResource(MODS.sfnMod.value, "Activity")},
        "aws_sfn_state_machine": {
            "Tok": awsResource(MODS.sfnMod.value, "StateMachine")
        },
        # Simple Workflow Service (SWF)
        "aws_swf_domain": {"Tok": awsResource(MODS.swfMod.value, "Domain")},
        # Synthetics
        "aws_synthetics_canary": {
            "Tok": awsResource(MODS.syntheticsMod.value, "Canary")
        },
        # Transfer Service
        "aws_transfer_server": {"Tok": awsResource(MODS.transferMod.value, "Server")},
        "aws_transfer_ssh_key": {"Tok": awsResource(MODS.transferMod.value, "SshKey")},
        "aws_transfer_user": {"Tok": awsResource(MODS.transferMod.value, "User")},
        "aws_transfer_access": {"Tok": awsResource(MODS.transferMod.value, "Access")},
        # TimestreamWrite
        "aws_timestreamwrite_database": {
            "Tok": awsResource(MODS.timestreamWriteMod.value, "Database")
        },
        "aws_timestreamwrite_table": {
            "Tok": awsResource(MODS.timestreamWriteMod.value, "Table")
        },
        # Web Application Firewall (WAF)
        "aws_waf_byte_match_set": {
            "Tok": awsResource(MODS.wafMod.value, "ByteMatchSet")
        },
        "aws_waf_geo_match_set": {"Tok": awsResource(MODS.wafMod.value, "GeoMatchSet")},
        "aws_waf_ipset": {"Tok": awsResource(MODS.wafMod.value, "IpSet")},
        "aws_waf_rate_based_rule": {
            "Tok": awsResource(MODS.wafMod.value, "RateBasedRule")
        },
        "aws_waf_regex_match_set": {
            "Tok": awsResource(MODS.wafMod.value, "RegexMatchSet")
        },
        "aws_waf_regex_pattern_set": {
            "Tok": awsResource(MODS.wafMod.value, "RegexPatternSet")
        },
        "aws_waf_rule": {"Tok": awsResource(MODS.wafMod.value, "Rule")},
        "aws_waf_rule_group": {"Tok": awsResource(MODS.wafMod.value, "RuleGroup")},
        "aws_waf_size_constraint_set": {
            "Tok": awsResource(MODS.wafMod.value, "SizeConstraintSet")
        },
        "aws_waf_web_acl": {"Tok": awsResource(MODS.wafMod.value, "WebAcl")},
        "aws_waf_xss_match_set": {"Tok": awsResource(MODS.wafMod.value, "XssMatchSet")},
        "aws_waf_sql_injection_match_set": {
            "Tok": awsResource(MODS.wafMod.value, "SqlInjectionMatchSet")
        },
        # Web Application Firewall V2 (WAFv2)
        "aws_wafv2_ip_set": {"Tok": awsResource(MODS.wafV2Mod.value, "IpSet")},
        "aws_wafv2_regex_pattern_set": {
            "Tok": awsResource(MODS.wafV2Mod.value, "RegexPatternSet")
        },
        "aws_wafv2_web_acl_association": {
            "Tok": awsResource(MODS.wafV2Mod.value, "WebAclAssociation")
        },
        "aws_wafv2_rule_group": {"Tok": awsResource(MODS.wafV2Mod.value, "RuleGroup")},
        "aws_wafv2_web_acl": {"Tok": awsResource(MODS.wafV2Mod.value, "WebAcl")},
        "aws_wafv2_web_acl_logging_configuration": {
            "Tok": awsResource(MODS.wafV2Mod.value, "WebAclLoggingConfiguration")
        },
        # Web Application Firewall (WAF) Regional
        "aws_wafregional_byte_match_set": {
            "Tok": awsResource(MODS.wafregionalMod.value, "ByteMatchSet"),
            "Fields": {
                "byte_match_tuples": {
                    "Name": "byteMatchTuples",
                },
            },
        },
        "aws_wafregional_geo_match_set": {
            "Tok": awsResource(MODS.wafregionalMod.value, "GeoMatchSet")
        },
        "aws_wafregional_ipset": {
            "Tok": awsResource(MODS.wafregionalMod.value, "IpSet")
        },
        "aws_wafregional_rate_based_rule": {
            "Tok": awsResource(MODS.wafregionalMod.value, "RateBasedRule")
        },
        "aws_wafregional_regex_match_set": {
            "Tok": awsResource(MODS.wafregionalMod.value, "RegexMatchSet")
        },
        "aws_wafregional_regex_pattern_set": {
            "Tok": awsResource(MODS.wafregionalMod.value, "RegexPatternSet")
        },
        "aws_wafregional_rule": {"Tok": awsResource(MODS.wafregionalMod.value, "Rule")},
        "aws_wafregional_rule_group": {
            "Tok": awsResource(MODS.wafregionalMod.value, "RuleGroup")
        },
        "aws_wafregional_size_constraint_set": {
            "Tok": awsResource(MODS.wafregionalMod.value, "SizeConstraintSet")
        },
        "aws_wafregional_sql_injection_match_set": {
            "Tok": awsResource(MODS.wafregionalMod.value, "SqlInjectionMatchSet")
        },
        "aws_wafregional_web_acl": {
            "Tok": awsResource(MODS.wafregionalMod.value, "WebAcl")
        },
        "aws_wafregional_web_acl_association": {
            "Tok": awsResource(MODS.wafregionalMod.value, "WebAclAssociation")
        },
        "aws_wafregional_xss_match_set": {
            "Tok": awsResource(MODS.wafregionalMod.value, "XssMatchSet")
        },
        # Worklink
        "aws_worklink_fleet": {"Tok": awsResource(MODS.worklinkMod.value, "Fleet")},
        "aws_worklink_website_certificate_authority_association": {
            "Tok": awsResource(
                MODS.worklinkMod.value, "WebsiteCertificateAuthorityAssociation"
            ),
        },
        # Xray
        "aws_xray_sampling_rule": {
            "Tok": awsResource(MODS.xrayMod.value, "SamplingRule")
        },
        "aws_xray_encryption_config": {
            "Tok": awsResource(MODS.xrayMod.value, "EncryptionConfig")
        },
        "aws_xray_group": {"Tok": awsResource(MODS.xrayMod.value, "Group")},
        # MSK
        "aws_msk_cluster": {
            "Tok": awsResource(MODS.mskMod.value, "Cluster"),
            "Fields": {
                "cluster_name": AutoName("clusterName", 255, "-"),
            },
        },
        "aws_msk_configuration": {
            "Tok": awsResource(MODS.mskMod.value, "Configuration")
        },
        "aws_msk_scram_secret_association": {
            "Tok": awsResource(MODS.mskMod.value, "ScramSecretAssociation")
        },
        # Datapipeline
        "aws_datapipeline_pipeline": {
            "Tok": awsResource(MODS.datapipelineMod.value, "Pipeline")
        },
        # Quicksight
        "aws_quicksight_group": {"Tok": awsResource(MODS.quicksightMod.value, "Group")},
        "aws_quicksight_user": {"Tok": awsResource(MODS.quicksightMod.value, "User")},
        "aws_quicksight_group_membership": {
            "Tok": awsResource(MODS.quicksightMod.value, "GroupMembership")
        },
        # Service Quotas
        "aws_servicequotas_service_quota": {
            "Tok": awsResource(MODS.servicequotasMod.value, "ServiceQuota")
        },
        # FMS
        "aws_fms_admin_account": {
            "Tok": awsResource(MODS.fmsMod.value, "AdminAccount")
        },
        "aws_fms_policy": {"Tok": awsResource(MODS.fmsMod.value, "Policy")},
        # QLDB
        "aws_qldb_ledger": {"Tok": awsResource(MODS.qldbMod.value, "Ledger")},
        # Workspaces
        "aws_workspaces_ip_group": {
            "Tok": awsResource(MODS.workspacesMod.value, "IpGroup")
        },
        "aws_workspaces_directory": {
            "Tok": awsResource(MODS.workspacesMod.value, "Directory")
        },
        "aws_workspaces_workspace": {
            "Tok": awsResource(MODS.workspacesMod.value, "Workspace")
        },
        # Access Analyzer
        "aws_accessanalyzer_analyzer": {
            "Tok": awsResource(MODS.accessAnalyzerMod.value, "Analyzer")
        },
        # CodeStar Notifications
        "aws_codestarnotifications_notification_rule": {
            "Tok": awsResource(MODS.codestarNotificationsMod.value, "NotificationRule"),
        },
        # Lex
        "aws_lex_slot_type": {
            "Tok": awsResource(MODS.lexMod.value, "SlotType"),
            "Fields": {
                "name": {
                    "Default": {
                        # This means the name will adhere to ^([A-Za-z]_?)+$  as per
                        # https:#docs.aws.amazon.com/lex/latest/dg/API_PutSlotType.html
                        "From": FromName(
                            Transform=lambda name: f"{name}_{transformWithRandomString(8)}"
                        ),
                    },
                },
            },
        },
        "aws_lex_bot": {
            "Tok": awsResource(MODS.lexMod.value, "Bot"),
            "Fields": {
                "name": {
                    "Default": {
                        # This means the name will adhere to ^([A-Za-z]_?)+$  as per
                        # https:#docs.aws.amazon.com/lex/latest/dg/API_PutBot.html
                        "From": FromName(
                            Transform=lambda name: f"{name}_{transformWithRandomString(8)}"
                        ),
                    },
                },
            },
        },
        "aws_lex_intent": {
            "Tok": awsResource(MODS.lexMod.value, "Intent"),
            "Fields": {
                "name": {
                    "Default": {
                        # This means the name will adhere to ^([A-Za-z]_?)+$  as per
                        # https:#docs.aws.amazon.com/lex/latest/dg/API_PutIntent.html
                        "From": FromName(
                            Transform=lambda name: f"{name}_{transformWithRandomString(8)}"
                        ),
                    },
                },
            },
        },
        "aws_lex_bot_alias": {
            "Tok": awsResource(MODS.lexMod.value, "BotAlias"),
            "Fields": {
                "name": {
                    "Default": {
                        # This means the name will adhere to ^([A-Za-z]_?)+$  as per
                        # https:#docs.aws.amazon.com/lex/latest/dg/API_PutBotAlias.html
                        "From": FromName(
                            Transform=lambda name: f"{name}_{transformWithRandomString(8)}"
                        ),
                    },
                },
            },
        },
        # Codeartifact
        "aws_codeartifact_domain": {
            "Tok": awsResource(MODS.codeartifactMod.value, "Domain"),
            "Fields": {
                "domain": {
                    "CsharpName": "DomainName",
                },
            },
        },
        "aws_codeartifact_repository": {
            "Tok": awsResource(MODS.codeartifactMod.value, "Repository"),
            "Fields": {
                "repository": {
                    "CsharpName": "RepositoryName",
                },
            },
        },
        "aws_codeartifact_domain_permissions_policy": {
            "Tok": awsResource(MODS.codeartifactMod.value, "DomainPermissions")
        },
        "aws_codeartifact_repository_permissions_policy": {
            "Tok": awsResource(
                MODS.codeartifactMod.value, "RepositoryPermissionsPolicy"
            ),
        },
        # Imagebuilder
        "aws_imagebuilder_image": {
            "Tok": awsResource(MODS.imageBuilderMod.value, "Image")
        },
        "aws_imagebuilder_component": {
            "Tok": awsResource(MODS.imageBuilderMod.value, "Component")
        },
        "aws_imagebuilder_image_pipeline": {
            "Tok": awsResource(MODS.imageBuilderMod.value, "ImagePipeline")
        },
        "aws_imagebuilder_image_recipe": {
            "Tok": awsResource(MODS.imageBuilderMod.value, "ImageRecipe")
        },
        "aws_imagebuilder_distribution_configuration": {
            "Tok": awsResource(MODS.imageBuilderMod.value, "DistributionConfiguration"),
        },
        "aws_imagebuilder_infrastructure_configuration": {
            "Tok": awsResource(
                MODS.imageBuilderMod.value, "InfrastructureConfiguration"
            ),
        },
        # Network firewall
        "aws_networkfirewall_firewall": {
            "Tok": awsResource(MODS.networkFirewallMod.value, "Firewall")
        },
        "aws_networkfirewall_firewall_policy": {
            "Tok": awsResource(MODS.networkFirewallMod.value, "FirewallPolicy"),
            "Fields": {
                "firewall_policy": {
                    "CsharpName": "FirewallPolicyConfiguration",
                },
            },
        },
        "aws_networkfirewall_logging_configuration": {
            "Tok": awsResource(MODS.networkFirewallMod.value, "LoggingConfiguration"),
            "Fields": {
                "logging_configuration": {
                    "CsharpName": "LoggingConfig",
                },
            },
        },
        "aws_networkfirewall_rule_group": {
            "Tok": awsResource(MODS.networkFirewallMod.value, "RuleGroup"),
            "Fields": {
                "rule_group": {
                    "CsharpName": "RuleGroupConfiguration",
                },
            },
        },
        "aws_networkfirewall_resource_policy": {
            "Tok": awsResource(MODS.networkFirewallMod.value, "ResourcePolicy")
        },
        # signer
        "aws_signer_signing_job": {
            "Tok": awsResource(MODS.signerMod.value, "SigningJob")
        },
        "aws_signer_signing_profile": {
            "Tok": awsResource(MODS.signerMod.value, "SigningProfile")
        },
        "aws_signer_signing_profile_permission": {
            "Tok": awsResource(MODS.signerMod.value, "SigningProfilePermission")
        },
        # ServerlessRepository
        "aws_serverlessapplicationrepository_cloudformation_stack": {
            "Tok": awsResource(
                MODS.serverlessRepositoryMod.value, "CloudFormationStack"
            ),
        },
        # Lakeformation
        "aws_lakeformation_data_lake_settings": {
            "Tok": awsResource(MODS.lakeFormationMod.value, "DataLakeSettings")
        },
        "aws_lakeformation_permissions": {
            "Tok": awsResource(MODS.lakeFormationMod.value, "Permissions"),
            "Fields": {
                "permissions": {
                    "CsharpName": "PermissionDetails",
                },
            },
        },
        "aws_lakeformation_resource": {
            "Tok": awsResource(MODS.lakeFormationMod.value, "Resource")
        },
        # codestar connections
        "aws_codestarconnections_connection": {
            "Tok": awsResource(MODS.codestarConnectionsMod.value, "Connection")
        },
        "aws_codestarconnections_host": {
            "Tok": awsResource(MODS.codestarConnectionsMod.value, "Host")
        },
        # SSO Admin
        "aws_ssoadmin_managed_policy_attachment": {
            "Tok": awsResource(MODS.ssoAdminMod.value, "ManagedPolicyAttachment")
        },
        "aws_ssoadmin_permission_set": {
            "Tok": awsResource(MODS.ssoAdminMod.value, "PermissionSet")
        },
        "aws_ssoadmin_permission_set_inline_policy": {
            "Tok": awsResource(MODS.ssoAdminMod.value, "PermissionSetInlinePolicy")
        },
        "aws_ssoadmin_account_assignment": {
            "Tok": awsResource(MODS.ssoAdminMod.value, "AccountAssignment")
        },
        # AMP (Managed Prometheus)
        "aws_prometheus_workspace": {
            "Tok": awsResource(MODS.ampMod.value, "Workspace")
        },
        # Amplify
        "aws_amplify_app": {"Tok": awsResource(MODS.amplifyMod.value, "App")},
        "aws_amplify_backend_environment": {
            "Tok": awsResource(MODS.amplifyMod.value, "BackendEnvironment")
        },
        "aws_amplify_branch": {"Tok": awsResource(MODS.amplifyMod.value, "Branch")},
        "aws_amplify_domain_association": {
            "Tok": awsResource(MODS.amplifyMod.value, "DomainAssociation")
        },
        "aws_amplify_webhook": {"Tok": awsResource(MODS.amplifyMod.value, "Webhook")},
        # appconfig
        "aws_appconfig_application": {
            "Tok": awsResource(MODS.appConfigMod.value, "Application")
        },
        "aws_appconfig_configuration_profile": {
            "Tok": awsResource(MODS.appConfigMod.value, "ConfigurationProfile")
        },
        "aws_appconfig_deployment_strategy": {
            "Tok": awsResource(MODS.appConfigMod.value, "DeploymentStrategy")
        },
        "aws_appconfig_environment": {
            "Tok": awsResource(MODS.appConfigMod.value, "Environment")
        },
        "aws_appconfig_hosted_configuration_version": {
            "Tok": awsResource(MODS.appConfigMod.value, "HostedConfigurationVersion")
        },
        "aws_appconfig_deployment": {
            "Tok": awsResource(MODS.appConfigMod.value, "Deployment")
        },
        # AppStream
        "aws_appstream_stack": {"Tok": awsResource(MODS.appStreamMod.value, "Stack")},
        "aws_appstream_fleet": {"Tok": awsResource(MODS.appStreamMod.value, "Fleet")},
        # mwaa
        "aws_mwaa_environment": {"Tok": awsResource(MODS.mwaaMod.value, "Environment")},
        # apprunner
        "aws_apprunner_auto_scaling_configuration_version": {
            "Tok": awsResource(
                MODS.appRunnerMod.value, "AutoScalingConfigurationVersion"
            )
        },
        "aws_apprunner_connection": {
            "Tok": awsResource(MODS.appRunnerMod.value, "Connection")
        },
        "aws_apprunner_custom_domain_association": {
            "Tok": awsResource(MODS.appRunnerMod.value, "CustomDomainAssociation")
        },
        "aws_apprunner_service": {
            "Tok": awsResource(MODS.appRunnerMod.value, "Service")
        },
    }

    def __init__(self) -> None:
        super().__init__()
        #  Fix the spelling mistake on `aws_ses_configuration_set` Tok
        self.RenameResourceWithAlias(
            "aws_ses_configuration_set",
            awsResource(MODS.sesMod.value, "ConfgurationSet"),
            awsResource(MODS.sesMod.value, "ConfigurationSet"),
            MODS.sesMod.value,
            MODS.sesMod.value,
            None,
        )

        #  Define the tf `elb` resources.  For legacy compat we also export them from the `elasticloadbalancing` module
        #  not just the `elb` module.
        self.RenameResourceWithAlias(
            "aws_app_cookie_stickiness_policy",
            awsResource(MODS.legacyElbMod.value, "AppCookieStickinessPolicy"),
            awsResource(MODS.elbMod.value, "AppCookieStickinessPolicy"),
            MODS.legacyElbMod.value,
            MODS.elbMod.value,
            None,
        )
        self.RenameResourceWithAlias(
            "aws_elb",
            awsResource(MODS.legacyElbMod.value, "LoadBalancer"),
            awsResource(MODS.elbMod.value, "LoadBalancer"),
            MODS.legacyElbMod.value,
            MODS.elbMod.value,
            None,
        )
        self.RenameResourceWithAlias(
            "aws_elb_attachment",
            awsResource(MODS.legacyElbMod.value, "Attachment"),
            awsResource(MODS.elbMod.value, "Attachment"),
            MODS.legacyElbMod.value,
            MODS.elbMod.value,
            None,
        )
        self.RenameResourceWithAlias(
            "aws_lb_cookie_stickiness_policy",
            awsResource(MODS.legacyElbMod.value, "LoadBalancerCookieStickinessPolicy"),
            awsResource(MODS.elbMod.value, "LoadBalancerCookieStickinessPolicy"),
            MODS.legacyElbMod.value,
            MODS.elbMod.value,
            None,
        )
        self.RenameResourceWithAlias(
            "aws_load_balancer_policy",
            awsResource(MODS.legacyElbMod.value, "LoadBalancerPolicy"),
            awsResource(MODS.elbMod.value, "LoadBalancerPolicy"),
            MODS.legacyElbMod.value,
            MODS.elbMod.value,
            None,
        )
        self.RenameResourceWithAlias(
            "aws_load_balancer_listener_policy",
            awsResource(MODS.legacyElbMod.value, "ListenerPolicy"),
            awsResource(MODS.elbMod.value, "ListenerPolicy"),
            MODS.legacyElbMod.value,
            MODS.elbMod.value,
            None,
        )
        self.RenameResourceWithAlias(
            "aws_lb_ssl_negotiation_policy",
            awsResource(MODS.legacyElbMod.value, "SslNegotiationPolicy"),
            awsResource(MODS.elbMod.value, "SslNegotiationPolicy"),
            MODS.legacyElbMod.value,
            MODS.elbMod.value,
            None,
        )
        self.RenameResourceWithAlias(
            "aws_load_balancer_backend_server_policy",
            awsResource(MODS.legacyElbMod.value, "LoadBalancerBackendServerPolicy"),
            awsResource(MODS.elbMod.value, "LoadBalancerBackendServerPolicy"),
            MODS.legacyElbMod.value,
            MODS.elbMod.value,
            None,
        )
        self.RenameDataSource(
            "aws_elb_hosted_zone_id",
            awsDataSource(MODS.legacyElbMod.value, "getHostedZoneId"),
            awsDataSource(MODS.elbMod.value, "getHostedZoneId"),
            MODS.legacyElbMod.value,
            MODS.elbMod.value,
            None,
        )
        self.RenameDataSource(
            "aws_elb_service_account",
            awsDataSource(MODS.legacyElbMod.value, "getServiceAccount"),
            awsDataSource(MODS.elbMod.value, "getServiceAccount"),
            MODS.legacyElbMod.value,
            MODS.elbMod.value,
            None,
        )
        self.RenameDataSource(
            "aws_elb",
            awsDataSource(MODS.legacyElbMod.value, "getLoadBalancer"),
            awsDataSource(MODS.elbMod.value, "getLoadBalancer"),
            MODS.legacyElbMod.value,
            MODS.elbMod.value,
            {
                "Fields": {
                    "access_logs": {"MaxItemsOne": True},
                    "health_check": {"MaxItemsOne": True},
                },
            },
        )

        #  Define the tf `lb` resources.  For legacy compat we also export them from the
        #  `elasticloadbalancingv2` module not just the `lb` module.
        self.RenameResourceWithAlias(
            "aws_lb",
            awsResource(MODS.legacyElbv2Mod.value, "LoadBalancer"),
            awsResource(MODS.lbMod.value, "LoadBalancer"),
            MODS.legacyElbv2Mod.value,
            MODS.lbMod.value,
            None,
        )
        self.RenameResourceWithAlias(
            "aws_lb_listener",
            awsResource(MODS.legacyElbv2Mod.value, "Listener"),
            awsResource(MODS.lbMod.value, "Listener"),
            MODS.legacyElbv2Mod.value,
            MODS.lbMod.value,
            None,
        )
        self.RenameResourceWithAlias(
            "aws_lb_listener_certificate",
            awsResource(MODS.legacyElbv2Mod.value, "ListenerCertificate"),
            awsResource(MODS.lbMod.value, "ListenerCertificate"),
            MODS.legacyElbv2Mod.value,
            MODS.lbMod.value,
            None,
        )
        self.RenameResourceWithAlias(
            "aws_lb_listener_rule",
            awsResource(MODS.legacyElbv2Mod.value, "ListenerRule"),
            awsResource(MODS.lbMod.value, "ListenerRule"),
            MODS.legacyElbv2Mod.value,
            MODS.lbMod.value,
            None,
        )
        self.RenameResourceWithAlias(
            "aws_lb_target_group",
            awsResource(MODS.legacyElbv2Mod.value, "TargetGroup"),
            awsResource(MODS.lbMod.value, "TargetGroup"),
            MODS.legacyElbv2Mod.value,
            MODS.lbMod.value,
            {
                "Fields": {
                    #  https:# docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_CreateTargetGroup.html
                    "name": AutoName("name", 63, "-"),
                },
            },
        )
        self.RenameResourceWithAlias(
            "aws_lb_target_group_attachment",
            awsResource(MODS.legacyElbv2Mod.value, "TargetGroupAttachment"),
            awsResource(MODS.lbMod.value, "TargetGroupAttachment"),
            MODS.legacyElbv2Mod.value,
            MODS.lbMod.value,
            None,
        )
        self.RenameDataSource(
            "aws_lb",
            awsDataSource(MODS.legacyElbv2Mod.value, "getLoadBalancer"),
            awsDataSource(MODS.lbMod.value, "getLoadBalancer"),
            MODS.legacyElbv2Mod.value,
            MODS.lbMod.value,
            {
                "Fields": {
                    "access_logs": {
                        "MaxItemsOne": True,
                    },
                },
            },
        )
        self.RenameDataSource(
            "aws_lb_listener",
            awsDataSource(MODS.legacyElbv2Mod.value, "getListener"),
            awsDataSource(MODS.lbMod.value, "getListener"),
            MODS.legacyElbv2Mod.value,
            MODS.lbMod.value,
            None,
        )
        self.RenameDataSource(
            "aws_lb_target_group",
            awsDataSource(MODS.legacyElbv2Mod.value, "getTargetGroup"),
            awsDataSource(MODS.lbMod.value, "getTargetGroup"),
            MODS.legacyElbv2Mod.value,
            MODS.lbMod.value,
            {
                "Fields": {
                    "stickiness": {
                        "MaxItemsOne": True,
                    },
                    "health_check": {
                        "MaxItemsOne": True,
                    },
                },
            },
        )

        #  Define the tf `alb` resources.  For legacy compat we also export them from the `applicationloadbalancing` module
        #  not just the `alb` module.
        self.RenameResourceWithAlias(
            "aws_alb",
            awsResource(MODS.legacyAlbMod.value, "LoadBalancer"),
            awsResource(MODS.albMod.value, "LoadBalancer"),
            MODS.legacyAlbMod.value,
            MODS.albMod.value,
            {
                "Fields": {
                    "load_balancer_type": {
                        "Type": awsResource(MODS.albMod.value, "LoadBalancerType")
                    },
                    "ip_address_type": {
                        "Type": awsResource(MODS.albMod.value, "IpAddressType")
                    },
                },
                "Docs": {"Source": "lb.html.markdown"},
            },
        )
        self.RenameResourceWithAlias(
            "aws_alb_listener",
            awsResource(MODS.legacyAlbMod.value, "Listener"),
            awsResource(MODS.albMod.value, "Listener"),
            MODS.legacyAlbMod.value,
            MODS.albMod.value,
            {
                "Docs": {"Source": "lb_listener.html.markdown"},
            },
        )
        self.RenameResourceWithAlias(
            "aws_alb_listener_certificate",
            awsResource(MODS.legacyAlbMod.value, "ListenerCertificate"),
            awsResource(MODS.albMod.value, "ListenerCertificate"),
            MODS.legacyAlbMod.value,
            MODS.albMod.value,
            {
                "Docs": {"Source": "lb_listener_certificate.html.markdown"},
            },
        )
        self.RenameResourceWithAlias(
            "aws_alb_listener_rule",
            awsResource(MODS.legacyAlbMod.value, "ListenerRule"),
            awsResource(MODS.albMod.value, "ListenerRule"),
            MODS.legacyAlbMod.value,
            MODS.albMod.value,
            {
                "Docs": {"Source": "lb_listener_rule.html.markdown"},
            },
        )
        self.RenameResourceWithAlias(
            "aws_alb_target_group",
            awsResource(MODS.legacyAlbMod.value, "TargetGroup"),
            awsResource(MODS.albMod.value, "TargetGroup"),
            MODS.legacyAlbMod.value,
            MODS.albMod.value,
            {
                "Docs": {"Source": "lb_target_group.html.markdown"},
            },
        )
        self.RenameResourceWithAlias(
            "aws_alb_target_group_attachment",
            awsResource(MODS.legacyAlbMod.value, "TargetGroupAttachment"),
            awsResource(MODS.albMod.value, "TargetGroupAttachment"),
            MODS.legacyAlbMod.value,
            MODS.albMod.value,
            {
                "Docs": {"Source": "lb_target_group_attachment.html.markdown"},
            },
        )
        self.RenameDataSource(
            "aws_alb",
            awsDataSource(MODS.legacyAlbMod.value, "getLoadBalancer"),
            awsDataSource(MODS.albMod.value, "getLoadBalancer"),
            MODS.legacyAlbMod.value,
            MODS.albMod.value,
            {
                "Docs": {"Source": "lb.html.markdown"},
                "Fields": {"access_logs": {"MaxItemsOne": True}},
            },
        )
        self.RenameDataSource(
            "aws_alb_listener",
            awsDataSource(MODS.legacyAlbMod.value, "getListener"),
            awsDataSource(MODS.albMod.value, "getListener"),
            MODS.legacyAlbMod.value,
            MODS.albMod.value,
            {
                "Docs": {"Source": "lb_listener.html.markdown"},
            },
        )
        self.RenameDataSource(
            "aws_alb_target_group",
            awsDataSource(MODS.legacyAlbMod.value, "getTargetGroup"),
            awsDataSource(MODS.albMod.value, "getTargetGroup"),
            MODS.legacyAlbMod.value,
            MODS.albMod.value,
            {
                "Docs": {"Source": "lb_target_group.html.markdown"},
                "Fields": {
                    "health_check": {"MaxItemsOne": True},
                    "stickiness": {"MaxItemsOne": True},
                },
            },
        )

        #  re-homing top level packages - https:# github.com/pulumi/pulumi-aws/issues/1352
        self.RenameDataSource(
            "aws_ami",
            awsDataSource(MODS.awsMod.value, "getAmi"),
            awsDataSource(MODS.ec2Mod.value, "getAmi"),
            MODS.awsMod.value,
            MODS.ec2Mod.value,
            None,
        )
        self.RenameDataSource(
            "aws_ami_ids",
            awsDataSource(MODS.awsMod.value, "getAmiIds"),
            awsDataSource(MODS.ec2Mod.value, "getAmiIds"),
            MODS.awsMod.value,
            MODS.ec2Mod.value,
            None,
        )
        self.RenameDataSource(
            "aws_eip",
            awsDataSource(MODS.awsMod.value, "getElasticIp"),
            awsDataSource(MODS.ec2Mod.value, "getElasticIp"),
            MODS.awsMod.value,
            MODS.ec2Mod.value,
            None,
        )
        self.RenameDataSource(
            "aws_prefix_list",
            awsDataSource(MODS.awsMod.value, "getPrefixList"),
            awsDataSource(MODS.ec2Mod.value, "getPrefixList"),
            MODS.awsMod.value,
            MODS.ec2Mod.value,
            None,
        )
        self.RenameDataSource(
            "aws_autoscaling_groups",
            awsDataSource(MODS.awsMod.value, "getAutoscalingGroups"),
            awsDataSource(MODS.autoscalingMod.value, "getAmiIds"),
            MODS.awsMod.value,
            MODS.autoscalingMod.value,
            None,
        )
        self.RenameDataSource(
            "aws_canonical_user_id",
            awsDataSource(MODS.awsMod.value, "getCanonicalUserId"),
            awsDataSource(MODS.s3Mod.value, "getCanonicalUserId"),
            MODS.awsMod.value,
            MODS.s3Mod.value,
            None,
        )

        self.SetAutonaming(255, "-")
